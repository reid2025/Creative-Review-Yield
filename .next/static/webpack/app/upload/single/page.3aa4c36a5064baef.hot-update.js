"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/upload/single/page",{

/***/ "(app-pages-browser)/./lib/firebase-draft-service.ts":
/*!***************************************!*\
  !*** ./lib/firebase-draft-service.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseDraftService: () => (/* binding */ FirebaseDraftService)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n// Firebase Draft Service - Real-time draft management with Firestore\n\n\n\nclass FirebaseDraftService {\n    /**\r\n   * Test Firebase connection\r\n   */ static async testConnection() {\n        try {\n            console.log('ðŸ”¥ Testing Firebase connection...');\n            // Try to read from Firestore\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            console.log('âœ… Firebase connection test successful');\n            return true;\n        } catch (error) {\n            console.error('âŒ Firebase connection test failed:', error);\n            return false;\n        }\n    }\n    /**\r\n   * Clean object to remove undefined values (Firebase doesn't accept undefined)\r\n   */ static cleanObject(obj) {\n        if (obj === null || obj === undefined) {\n            return null;\n        }\n        if (Array.isArray(obj)) {\n            return obj.map((item)=>this.cleanObject(item));\n        }\n        if (typeof obj === 'object' && obj.constructor === Object) {\n            const cleaned = {};\n            for(const key in obj){\n                if (obj.hasOwnProperty(key)) {\n                    const value = obj[key];\n                    if (value !== undefined) {\n                        cleaned[key] = this.cleanObject(value);\n                    }\n                }\n            }\n            return cleaned;\n        }\n        return obj;\n    }\n    /**\r\n   * Save or update a draft in Firestore\r\n   */ static async saveDraft(data, imageFile) {\n        try {\n            console.log('ðŸ”¥ Firebase saveDraft called with data:', data);\n            // Clean the formData to remove non-serializable objects like File and undefined values\n            const cleanFormData = this.cleanObject({\n                ...data.formData\n            });\n            if (cleanFormData && cleanFormData.uploadedImage) {\n                // Store only file metadata, not the actual File object\n                const file = cleanFormData.uploadedImage;\n                if (file && typeof file === 'object' && file.name) {\n                    cleanFormData.uploadedImage = {\n                        name: file.name,\n                        size: file.size,\n                        type: file.type,\n                        lastModified: file.lastModified,\n                        isFileObject: true // Flag to identify this was a file\n                    };\n                }\n            }\n            // Clean the entire draft data object to remove undefined values\n            const draftData = this.cleanObject({\n                draftId: data.draftId || this.generateDraftId(),\n                creativeFilename: data.creativeFilename || 'Untitled',\n                lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                autoSaved: data.autoSaved || false,\n                formData: cleanFormData || {},\n                aiPopulatedFields: data.aiPopulatedFields || [],\n                version: (data.version || 0) + 1,\n                isActive: true,\n                userId: data.userId || 'anonymous' // In production, use actual user ID\n            });\n            console.log('ðŸ”¥ Prepared draft data for Firebase:', draftData);\n            // Handle image upload if provided (skip if storage permission issues)\n            if (imageFile) {\n                try {\n                    const imageData = await this.uploadImage(imageFile, draftData.draftId);\n                    draftData.imageUrl = imageData.downloadUrl;\n                    draftData.imageStoragePath = imageData.storagePath;\n                    console.log('âœ… Image uploaded successfully');\n                } catch (imageError) {\n                    console.warn('âš ï¸ Image upload failed, continuing without image:', imageError);\n                // Don't fail the entire draft save if image upload fails\n                }\n            }\n            // If draftId exists, update existing document\n            if (data.id) {\n                console.log('ðŸ”¥ Updating existing draft with ID:', data.id);\n                const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, data.id);\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(draftRef, {\n                    ...draftData,\n                    lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                });\n                console.log('âœ… Draft updated successfully:', data.id);\n                return data.id;\n            } else {\n                // Create new draft\n                console.log('ðŸ”¥ Creating new draft document');\n                draftData.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)();\n                const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), draftData);\n                console.log('âœ… New draft created with ID:', docRef.id);\n                return docRef.id;\n            }\n        } catch (error) {\n            console.error('âŒ Failed to save draft to Firebase:', error);\n            console.error('Firebase error details:', error);\n            throw new Error(\"Failed to save draft: \".concat(error));\n        }\n    }\n    /**\r\n   * Get a single draft by ID\r\n   */ static async getDraft(id) {\n        try {\n            const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, id);\n            const draftSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(draftRef);\n            if (draftSnap.exists()) {\n                return {\n                    id: draftSnap.id,\n                    ...draftSnap.data()\n                };\n            }\n            return null;\n        } catch (error) {\n            console.error('Failed to get draft:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Get all active drafts for a user\r\n   */ static async getAllDrafts() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous';\n        try {\n            // Simplified query to avoid needing a composite index\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const drafts = [];\n            querySnapshot.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            // Sort by lastSaved in memory to avoid needing a composite index\n            return drafts.sort((a, b)=>{\n                var _a_lastSaved_toDate, _a_lastSaved_toDate1, _a_lastSaved, _b_lastSaved_toDate, _b_lastSaved_toDate1, _b_lastSaved;\n                const aTime = ((_a_lastSaved = a.lastSaved) === null || _a_lastSaved === void 0 ? void 0 : (_a_lastSaved_toDate1 = _a_lastSaved.toDate) === null || _a_lastSaved_toDate1 === void 0 ? void 0 : (_a_lastSaved_toDate = _a_lastSaved_toDate1.call(_a_lastSaved)) === null || _a_lastSaved_toDate === void 0 ? void 0 : _a_lastSaved_toDate.getTime()) || 0;\n                const bTime = ((_b_lastSaved = b.lastSaved) === null || _b_lastSaved === void 0 ? void 0 : (_b_lastSaved_toDate1 = _b_lastSaved.toDate) === null || _b_lastSaved_toDate1 === void 0 ? void 0 : (_b_lastSaved_toDate = _b_lastSaved_toDate1.call(_b_lastSaved)) === null || _b_lastSaved_toDate === void 0 ? void 0 : _b_lastSaved_toDate.getTime()) || 0;\n                return bTime - aTime // Desc order\n                ;\n            });\n        } catch (error) {\n            console.error('Failed to get drafts:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Delete a draft (soft delete by marking as inactive)\r\n   */ static async deleteDraft(id) {\n        try {\n            const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, id);\n            // Get draft data to clean up image if needed\n            const draftSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(draftRef);\n            if (draftSnap.exists()) {\n                const draftData = draftSnap.data();\n                // Delete image from storage if exists\n                if (draftData.imageStoragePath) {\n                    await this.deleteImage(draftData.imageStoragePath);\n                }\n            }\n            // Soft delete by marking as inactive\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(draftRef, {\n                isActive: false,\n                lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            });\n            return true;\n        } catch (error) {\n            console.error('Failed to delete draft:', error);\n            return false;\n        }\n    }\n    /**\r\n   * Set up real-time listener for drafts\r\n   */ static onDraftsChange() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous', callback = arguments.length > 1 ? arguments[1] : void 0;\n        // Simplified query to avoid needing a composite index\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n        return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot)(q, (querySnapshot)=>{\n            const drafts = [];\n            querySnapshot.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            // Sort by lastSaved in memory to avoid needing a composite index\n            const sortedDrafts = drafts.sort((a, b)=>{\n                var _a_lastSaved_toDate, _a_lastSaved_toDate1, _a_lastSaved, _b_lastSaved_toDate, _b_lastSaved_toDate1, _b_lastSaved;\n                const aTime = ((_a_lastSaved = a.lastSaved) === null || _a_lastSaved === void 0 ? void 0 : (_a_lastSaved_toDate1 = _a_lastSaved.toDate) === null || _a_lastSaved_toDate1 === void 0 ? void 0 : (_a_lastSaved_toDate = _a_lastSaved_toDate1.call(_a_lastSaved)) === null || _a_lastSaved_toDate === void 0 ? void 0 : _a_lastSaved_toDate.getTime()) || 0;\n                const bTime = ((_b_lastSaved = b.lastSaved) === null || _b_lastSaved === void 0 ? void 0 : (_b_lastSaved_toDate1 = _b_lastSaved.toDate) === null || _b_lastSaved_toDate1 === void 0 ? void 0 : (_b_lastSaved_toDate = _b_lastSaved_toDate1.call(_b_lastSaved)) === null || _b_lastSaved_toDate === void 0 ? void 0 : _b_lastSaved_toDate.getTime()) || 0;\n                return bTime - aTime // Desc order\n                ;\n            });\n            callback(sortedDrafts);\n        }, (error)=>{\n            console.error('Real-time drafts listener error:', error);\n        });\n    }\n    /**\r\n   * Set up real-time listener for a specific draft\r\n   */ static onDraftChange(draftId, callback) {\n        const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, draftId);\n        return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot)(draftRef, (doc)=>{\n            if (doc.exists()) {\n                callback({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            } else {\n                callback(null);\n            }\n        }, (error)=>{\n            console.error('Real-time draft listener error:', error);\n        });\n    }\n    /**\r\n   * Upload image to Firebase Storage\r\n   */ static async uploadImage(file, draftId) {\n        try {\n            const storagePath = \"\".concat(this.STORAGE_PATH, \"/\").concat(draftId, \"/\").concat(file.name);\n            const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, storagePath);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.uploadBytes)(imageRef, file);\n            const downloadUrl = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.getDownloadURL)(imageRef);\n            return {\n                downloadUrl,\n                storagePath\n            };\n        } catch (error) {\n            console.error('Failed to upload image:', error);\n            throw new Error('Failed to upload image');\n        }\n    }\n    /**\r\n   * Delete image from Firebase Storage\r\n   */ static async deleteImage(storagePath) {\n        try {\n            const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, storagePath);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.deleteObject)(imageRef);\n        } catch (error) {\n            console.error('Failed to delete image:', error);\n        // Don't throw error as this is cleanup\n        }\n    }\n    /**\r\n   * Generate unique draft ID\r\n   */ static generateDraftId() {\n        return \"draft_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    /**\r\n   * Migrate existing localStorage drafts to Firebase\r\n   */ static async migrateLocalDrafts() {\n        try {\n            // Import the existing draft storage to access local drafts\n            const { DraftStorageV2 } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_utils_draftStorage_v2_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../utils/draftStorage.v2 */ \"(app-pages-browser)/./utils/draftStorage.v2.ts\"));\n            const localDrafts = DraftStorageV2.getAllDrafts();\n            console.log(\"Found \".concat(localDrafts.length, \" local drafts to migrate\"));\n            for (const localDraft of localDrafts){\n                try {\n                    const firebaseDraft = {\n                        draftId: localDraft.draftId,\n                        creativeFilename: localDraft.creativeFilename,\n                        formData: localDraft.formData,\n                        autoSaved: localDraft.autoSaved,\n                        version: 1,\n                        isActive: true\n                    };\n                    await this.saveDraft(firebaseDraft);\n                    console.log(\"Migrated draft: \".concat(localDraft.creativeFilename));\n                } catch (error) {\n                    console.error(\"Failed to migrate draft \".concat(localDraft.draftId, \":\"), error);\n                }\n            }\n            console.log('Draft migration completed');\n        } catch (error) {\n            console.error('Failed to migrate local drafts:', error);\n        }\n    }\n    /**\r\n   * Get real-time tracking statistics\r\n   */ static async getTrackingStats() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous';\n        try {\n            const drafts = await this.getAllDrafts(userId);\n            const stats = {\n                totalDrafts: drafts.length,\n                autoSavedCount: drafts.filter((d)=>d.autoSaved).length,\n                manualSavedCount: drafts.filter((d)=>!d.autoSaved).length,\n                aiPopulatedCount: drafts.filter((d)=>d.aiPopulatedFields && d.aiPopulatedFields.length > 0).length\n            };\n            return stats;\n        } catch (error) {\n            console.error('Failed to get tracking stats:', error);\n            return {\n                totalDrafts: 0,\n                autoSavedCount: 0,\n                manualSavedCount: 0,\n                aiPopulatedCount: 0\n            };\n        }\n    }\n}\nFirebaseDraftService.COLLECTION_NAME = 'drafts';\nFirebaseDraftService.STORAGE_PATH = 'draft-images';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9maXJlYmFzZS1kcmFmdC1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxxRUFBcUU7QUFlMUM7QUFDc0Q7QUFDekM7QUFtQmpDLE1BQU1nQjtJQUlYOztHQUVDLEdBQ0QsYUFBYUMsaUJBQW1DO1FBQzlDLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osNkJBQTZCO1lBQzdCLE1BQU1DLElBQUliLHlEQUFLQSxDQUFDUCw4REFBVUEsQ0FBQ2MseUNBQUVBLEVBQUUsSUFBSSxDQUFDTyxlQUFlLEdBQUdiLHlEQUFLQSxDQUFDLFlBQVksTUFBTTtZQUM5RSxNQUFNSiwyREFBT0EsQ0FBQ2dCO1lBQ2RGLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU87UUFDVCxFQUFFLE9BQU9HLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLHNDQUFzQ0E7WUFDcEQsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQWVDLFlBQVlDLEdBQVEsRUFBTztRQUN4QyxJQUFJQSxRQUFRLFFBQVFBLFFBQVFDLFdBQVc7WUFDckMsT0FBTztRQUNUO1FBRUEsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxNQUFNO1lBQ3RCLE9BQU9BLElBQUlJLEdBQUcsQ0FBQ0MsQ0FBQUEsT0FBUSxJQUFJLENBQUNOLFdBQVcsQ0FBQ007UUFDMUM7UUFFQSxJQUFJLE9BQU9MLFFBQVEsWUFBWUEsSUFBSU0sV0FBVyxLQUFLQyxRQUFRO1lBQ3pELE1BQU1DLFVBQWUsQ0FBQztZQUN0QixJQUFLLE1BQU1DLE9BQU9ULElBQUs7Z0JBQ3JCLElBQUlBLElBQUlVLGNBQWMsQ0FBQ0QsTUFBTTtvQkFDM0IsTUFBTUUsUUFBUVgsR0FBRyxDQUFDUyxJQUFJO29CQUN0QixJQUFJRSxVQUFVVixXQUFXO3dCQUN2Qk8sT0FBTyxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDVixXQUFXLENBQUNZO29CQUNsQztnQkFDRjtZQUNGO1lBQ0EsT0FB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TWtELFFBQVE7Z0JBQ1pDLGFBQWFoQyxPQUFPMkIsTUFBTTtnQkFDMUJNLGdCQUFnQmpDLE9BQU9rQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUUxRCxTQUFTLEVBQUVrRCxNQUFNO2dCQUN0RFMsa0JBQWtCcEMsT0FBT2tDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBSyxDQUFDQSxFQUFFMUQsU0FBUyxFQUFFa0QsTUFBTTtnQkFDekRVLGtCQUFrQnJDLE9BQU9rQyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUV6RCxpQkFBaUIsSUFBSXlELEVBQUV6RCxpQkFBaUIsQ0FBQ2lELE1BQU0sR0FBRyxHQUFHQSxNQUFNO1lBQ3BHO1lBRUEsT0FBT0k7UUFDVCxFQUFFLE9BQU9yRixPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE9BQU87Z0JBQ0xzRixhQUFhO2dCQUNiQyxnQkFBZ0I7Z0JBQ2hCRyxrQkFBa0I7Z0JBQ2xCQyxrQkFBa0I7WUFDcEI7UUFDRjtJQUNGO0FBQ0Y7QUEvV2FqRyxxQkFDYUssa0JBQWtCO0FBRC9CTCxxQkFFYTRFLGVBQWUiLCJzb3VyY2VzIjpbIkQ6XFxJc3RpYW4gRmlsZXNcXFRpc2VnXFxDUlkgQXBwXFxsaWJcXGZpcmViYXNlLWRyYWZ0LXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlyZWJhc2UgRHJhZnQgU2VydmljZSAtIFJlYWwtdGltZSBkcmFmdCBtYW5hZ2VtZW50IHdpdGggRmlyZXN0b3JlXHJcbmltcG9ydCB7IFxyXG4gIGNvbGxlY3Rpb24sIFxyXG4gIGRvYywgXHJcbiAgYWRkRG9jLCBcclxuICB1cGRhdGVEb2MsIFxyXG4gIGRlbGV0ZURvYywgXHJcbiAgZ2V0RG9jcywgXHJcbiAgZ2V0RG9jLFxyXG4gIG9uU25hcHNob3QsXHJcbiAgcXVlcnksXHJcbiAgd2hlcmUsXHJcbiAgb3JkZXJCeSxcclxuICBUaW1lc3RhbXAsXHJcbiAgc2VydmVyVGltZXN0YW1wXHJcbn0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJ1xyXG5pbXBvcnQgeyByZWYsIHVwbG9hZEJ5dGVzLCBnZXREb3dubG9hZFVSTCwgZGVsZXRlT2JqZWN0IH0gZnJvbSAnZmlyZWJhc2Uvc3RvcmFnZSdcclxuaW1wb3J0IHsgZGIsIHN0b3JhZ2UgfSBmcm9tICcuL2ZpcmViYXNlJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGaXJlYmFzZURyYWZ0RGF0YSB7XHJcbiAgaWQ/OiBzdHJpbmdcclxuICBkcmFmdElkOiBzdHJpbmdcclxuICBjcmVhdGl2ZUZpbGVuYW1lOiBzdHJpbmdcclxuICBsYXN0U2F2ZWQ6IFRpbWVzdGFtcFxyXG4gIGNyZWF0ZWRBdDogVGltZXN0YW1wXHJcbiAgYXV0b1NhdmVkPzogYm9vbGVhblxyXG4gIGZvcm1EYXRhOiBhbnlcclxuICBpbWFnZVVybD86IHN0cmluZ1xyXG4gIGltYWdlU3RvcmFnZVBhdGg/OiBzdHJpbmdcclxuICB1c2VySWQ/OiBzdHJpbmdcclxuICAvLyBBZGRpdGlvbmFsIHRyYWNraW5nIGZpZWxkcyBhcyBwZXIgcmVxdWlyZW1lbnRzXHJcbiAgYWlQb3B1bGF0ZWRGaWVsZHM/OiBzdHJpbmdbXVxyXG4gIHZlcnNpb246IG51bWJlclxyXG4gIGlzQWN0aXZlOiBib29sZWFuXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBGaXJlYmFzZURyYWZ0U2VydmljZSB7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09MTEVDVElPTl9OQU1FID0gJ2RyYWZ0cydcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVE9SQUdFX1BBVEggPSAnZHJhZnQtaW1hZ2VzJ1xyXG5cclxuICAvKipcclxuICAgKiBUZXN0IEZpcmViYXNlIGNvbm5lY3Rpb25cclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgdGVzdENvbm5lY3Rpb24oKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UpSBUZXN0aW5nIEZpcmViYXNlIGNvbm5lY3Rpb24uLi4nKVxyXG4gICAgICAvLyBUcnkgdG8gcmVhZCBmcm9tIEZpcmVzdG9yZVxyXG4gICAgICBjb25zdCBxID0gcXVlcnkoY29sbGVjdGlvbihkYiwgdGhpcy5DT0xMRUNUSU9OX05BTUUpLCB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKSlcclxuICAgICAgYXdhaXQgZ2V0RG9jcyhxKVxyXG4gICAgICBjb25zb2xlLmxvZygn4pyFIEZpcmViYXNlIGNvbm5lY3Rpb24gdGVzdCBzdWNjZXNzZnVsJylcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaXJlYmFzZSBjb25uZWN0aW9uIHRlc3QgZmFpbGVkOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFuIG9iamVjdCB0byByZW1vdmUgdW5kZWZpbmVkIHZhbHVlcyAoRmlyZWJhc2UgZG9lc24ndCBhY2NlcHQgdW5kZWZpbmVkKVxyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGNsZWFuT2JqZWN0KG9iajogYW55KTogYW55IHtcclxuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICByZXR1cm4gb2JqLm1hcChpdGVtID0+IHRoaXMuY2xlYW5PYmplY3QoaXRlbSkpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICBjb25zdCBjbGVhbmVkOiBhbnkgPSB7fVxyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV1cclxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNsZWFuZWRba2V5XSA9IHRoaXMuY2xlYW5PYmplY3QodmFsdWUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjbGVhbmVkXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBvYmpcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNhdmUgb3IgdXBkYXRlIGEgZHJhZnQgaW4gRmlyZXN0b3JlXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIHNhdmVEcmFmdChkYXRhOiBQYXJ0aWFsPEZpcmViYXNlRHJhZnREYXRhPiwgaW1hZ2VGaWxlPzogRmlsZSk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UpSBGaXJlYmFzZSBzYXZlRHJhZnQgY2FsbGVkIHdpdGggZGF0YTonLCBkYXRhKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYW4gdGhlIGZvcm1EYXRhIHRvIHJlbW92ZSBub24tc2VyaWFsaXphYmxlIG9iamVjdHMgbGlrZSBGaWxlIGFuZCB1bmRlZmluZWQgdmFsdWVzXHJcbiAgICAgIGNvbnN0IGNsZWFuRm9ybURhdGEgPSB0aGlzLmNsZWFuT2JqZWN0KHsgLi4uZGF0YS5mb3JtRGF0YSB9KVxyXG4gICAgICBpZiAoY2xlYW5Gb3JtRGF0YSAmJiBjbGVhbkZvcm1EYXRhLnVwbG9hZGVkSW1hZ2UpIHtcclxuICAgICAgICAvLyBTdG9yZSBvbmx5IGZpbGUgbWV0YWRhdGEsIG5vdCB0aGUgYWN0dWFsIEZpbGUgb2JqZWN0XHJcbiAgICAgICAgY29uc3QgZmlsZSA9IGNsZWFuRm9ybURhdGEudXBsb2FkZWRJbWFnZSBhcyBGaWxlXHJcbiAgICAgICAgaWYgKGZpbGUgJiYgdHlwZW9mIGZpbGUgPT09ICdvYmplY3QnICYmIGZpbGUubmFtZSkge1xyXG4gICAgICAgICAgY2xlYW5Gb3JtRGF0YS51cGxvYWRlZEltYWdlID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWUsXHJcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcclxuICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxyXG4gICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IGZpbGUubGFzdE1vZGlmaWVkLFxyXG4gICAgICAgICAgICBpc0ZpbGVPYmplY3Q6IHRydWUgLy8gRmxhZyB0byBpZGVudGlmeSB0aGlzIHdhcyBhIGZpbGVcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFuIHRoZSBlbnRpcmUgZHJhZnQgZGF0YSBvYmplY3QgdG8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgY29uc3QgZHJhZnREYXRhID0gdGhpcy5jbGVhbk9iamVjdCh7XHJcbiAgICAgICAgZHJhZnRJZDogZGF0YS5kcmFmdElkIHx8IHRoaXMuZ2VuZXJhdGVEcmFmdElkKCksXHJcbiAgICAgICAgY3JlYXRpdmVGaWxlbmFtZTogZGF0YS5jcmVhdGl2ZUZpbGVuYW1lIHx8ICdVbnRpdGxlZCcsXHJcbiAgICAgICAgbGFzdFNhdmVkOiBzZXJ2ZXJUaW1lc3RhbXAoKSBhcyBUaW1lc3RhbXAsXHJcbiAgICAgICAgYXV0b1NhdmVkOiBkYXRhLmF1dG9TYXZlZCB8fCBmYWxzZSxcclxuICAgICAgICBmb3JtRGF0YTogY2xlYW5Gb3JtRGF0YSB8fCB7fSxcclxuICAgICAgICBhaVBvcHVsYXRlZEZpZWxkczogZGF0YS5haVBvcHVsYXRlZEZpZWxkcyB8fCBbXSxcclxuICAgICAgICB2ZXJzaW9uOiAoZGF0YS52ZXJzaW9uIHx8IDApICsgMSxcclxuICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgICAgICB1c2VySWQ6IGRhdGEudXNlcklkIHx8ICdhbm9ueW1vdXMnIC8vIEluIHByb2R1Y3Rpb24sIHVzZSBhY3R1YWwgdXNlciBJRFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc29sZS5sb2coJ/CflKUgUHJlcGFyZWQgZHJhZnQgZGF0YSBmb3IgRmlyZWJhc2U6JywgZHJhZnREYXRhKVxyXG5cclxuICAgICAgLy8gSGFuZGxlIGltYWdlIHVwbG9hZCBpZiBwcm92aWRlZCAoc2tpcCBpZiBzdG9yYWdlIHBlcm1pc3Npb24gaXNzdWVzKVxyXG4gICAgICBpZiAoaW1hZ2VGaWxlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGF3YWl0IHRoaXMudXBsb2FkSW1hZ2UoaW1hZ2VGaWxlLCBkcmFmdERhdGEuZHJhZnRJZCEpXHJcbiAgICAgICAgICBkcmFmdERhdGEuaW1hZ2VVcmwgPSBpbWFnZURhdGEuZG93bmxvYWRVcmxcclxuICAgICAgICAgIGRyYWZ0RGF0YS5pbWFnZVN0b3JhZ2VQYXRoID0gaW1hZ2VEYXRhLnN0b3JhZ2VQYXRoXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEltYWdlIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseScpXHJcbiAgICAgICAgfSBjYXRjaCAoaW1hZ2VFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gSW1hZ2UgdXBsb2FkIGZhaWxlZCwgY29udGludWluZyB3aXRob3V0IGltYWdlOicsIGltYWdlRXJyb3IpXHJcbiAgICAgICAgICAvLyBEb24ndCBmYWlsIHRoZSBlbnRpcmUgZHJhZnQgc2F2ZSBpZiBpbWFnZSB1cGxvYWQgZmFpbHNcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIGRyYWZ0SWQgZXhpc3RzLCB1cGRhdGUgZXhpc3RpbmcgZG9jdW1lbnRcclxuICAgICAgaWYgKGRhdGEuaWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UpSBVcGRhdGluZyBleGlzdGluZyBkcmFmdCB3aXRoIElEOicsIGRhdGEuaWQpXHJcbiAgICAgICAgY29uc3QgZHJhZnRSZWYgPSBkb2MoZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FLCBkYXRhLmlkKVxyXG4gICAgICAgIGF3YWl0IHVwZGF0ZURvYyhkcmFmdFJlZiwge1xyXG4gICAgICAgICAgLi4uZHJhZnREYXRhLFxyXG4gICAgICAgICAgbGFzdFNhdmVkOiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBEcmFmdCB1cGRhdGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhLmlkKVxyXG4gICAgICAgIHJldHVybiBkYXRhLmlkXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBkcmFmdFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SlIENyZWF0aW5nIG5ldyBkcmFmdCBkb2N1bWVudCcpXHJcbiAgICAgICAgZHJhZnREYXRhLmNyZWF0ZWRBdCA9IHNlcnZlclRpbWVzdGFtcCgpIGFzIFRpbWVzdGFtcFxyXG4gICAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSksIGRyYWZ0RGF0YSlcclxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIE5ldyBkcmFmdCBjcmVhdGVkIHdpdGggSUQ6JywgZG9jUmVmLmlkKVxyXG4gICAgICAgIHJldHVybiBkb2NSZWYuaWRcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBzYXZlIGRyYWZ0IHRvIEZpcmViYXNlOicsIGVycm9yKVxyXG4gICAgICBjb25zb2xlLmVycm9yKCdGaXJlYmFzZSBlcnJvciBkZXRhaWxzOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzYXZlIGRyYWZ0OiAke2Vycm9yfWApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSBzaW5nbGUgZHJhZnQgYnkgSURcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgZ2V0RHJhZnQoaWQ6IHN0cmluZyk6IFByb21pc2U8RmlyZWJhc2VEcmFmdERhdGEgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkcmFmdFJlZiA9IGRvYyhkYiwgdGhpcy5DT0xMRUNUSU9OX05BTUUsIGlkKVxyXG4gICAgICBjb25zdCBkcmFmdFNuYXAgPSBhd2FpdCBnZXREb2MoZHJhZnRSZWYpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZHJhZnRTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGlkOiBkcmFmdFNuYXAuaWQsXHJcbiAgICAgICAgICAuLi5kcmFmdFNuYXAuZGF0YSgpXHJcbiAgICAgICAgfSBhcyBGaXJlYmFzZURyYWZ0RGF0YVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGRyYWZ0OicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFsbCBhY3RpdmUgZHJhZnRzIGZvciBhIHVzZXJcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgZ2V0QWxsRHJhZnRzKHVzZXJJZDogc3RyaW5nID0gJ2Fub255bW91cycpOiBQcm9taXNlPEZpcmViYXNlRHJhZnREYXRhW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNpbXBsaWZpZWQgcXVlcnkgdG8gYXZvaWQgbmVlZGluZyBhIGNvbXBvc2l0ZSBpbmRleFxyXG4gICAgICBjb25zdCBxID0gcXVlcnkoXHJcbiAgICAgICAgY29sbGVjdGlvbihkYiwgdGhpcy5DT0xMRUNUSU9OX05BTUUpLFxyXG4gICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxyXG4gICAgICAgIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpXHJcbiAgICAgIClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpXHJcbiAgICAgIGNvbnN0IGRyYWZ0czogRmlyZWJhc2VEcmFmdERhdGFbXSA9IFtdXHJcbiAgICAgIFxyXG4gICAgICBxdWVyeVNuYXBzaG90LmZvckVhY2goKGRvYykgPT4ge1xyXG4gICAgICAgIGRyYWZ0cy5wdXNoKHtcclxuICAgICAgICAgIGlkOiBkb2MuaWQsXHJcbiAgICAgICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICAgICAgfSBhcyBGaXJlYmFzZURyYWZ0RGF0YSlcclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIC8vIFNvcnQgYnkgbGFzdFNhdmVkIGluIG1lbW9yeSB0byBhdm9pZCBuZWVkaW5nIGEgY29tcG9zaXRlIGluZGV4XHJcbiAgICAgIHJldHVybiBkcmFmdHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFUaW1lID0gYS5sYXN0U2F2ZWQ/LnRvRGF0ZT8uKCk/LmdldFRpbWUoKSB8fCAwXHJcbiAgICAgICAgY29uc3QgYlRpbWUgPSBiLmxhc3RTYXZlZD8udG9EYXRlPy4oKT8uZ2V0VGltZSgpIHx8IDBcclxuICAgICAgICByZXR1cm4gYlRpbWUgLSBhVGltZSAvLyBEZXNjIG9yZGVyXHJcbiAgICAgIH0pXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGRyYWZ0czonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgYSBkcmFmdCAoc29mdCBkZWxldGUgYnkgbWFya2luZyBhcyBpbmFjdGl2ZSlcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgZGVsZXRlRHJhZnQoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZHJhZnRSZWYgPSBkb2MoZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FLCBpZClcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCBkcmFmdCBkYXRhIHRvIGNsZWFuIHVwIGltYWdlIGlmIG5lZWRlZFxyXG4gICAgICBjb25zdCBkcmFmdFNuYXAgPSBhd2FpdCBnZXREb2MoZHJhZnRSZWYpXHJcbiAgICAgIGlmIChkcmFmdFNuYXAuZXhpc3RzKCkpIHtcclxuICAgICAgICBjb25zdCBkcmFmdERhdGEgPSBkcmFmdFNuYXAuZGF0YSgpIGFzIEZpcmViYXNlRHJhZnREYXRhXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRGVsZXRlIGltYWdlIGZyb20gc3RvcmFnZSBpZiBleGlzdHNcclxuICAgICAgICBpZiAoZHJhZnREYXRhLmltYWdlU3RvcmFnZVBhdGgpIHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuZGVsZXRlSW1hZ2UoZHJhZnREYXRhLmltYWdlU3RvcmFnZVBhdGgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTb2Z0IGRlbGV0ZSBieSBtYXJraW5nIGFzIGluYWN0aXZlXHJcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhkcmFmdFJlZiwge1xyXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcclxuICAgICAgICBsYXN0U2F2ZWQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBkcmFmdDonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdXAgcmVhbC10aW1lIGxpc3RlbmVyIGZvciBkcmFmdHNcclxuICAgKi9cclxuICBzdGF0aWMgb25EcmFmdHNDaGFuZ2UodXNlcklkOiBzdHJpbmcgPSAnYW5vbnltb3VzJywgY2FsbGJhY2s6IChkcmFmdHM6IEZpcmViYXNlRHJhZnREYXRhW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcclxuICAgIC8vIFNpbXBsaWZpZWQgcXVlcnkgdG8gYXZvaWQgbmVlZGluZyBhIGNvbXBvc2l0ZSBpbmRleFxyXG4gICAgY29uc3QgcSA9IHF1ZXJ5KFxyXG4gICAgICBjb2xsZWN0aW9uKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSksXHJcbiAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxyXG4gICAgICB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKVxyXG4gICAgKVxyXG5cclxuICAgIHJldHVybiBvblNuYXBzaG90KHEsIChxdWVyeVNuYXBzaG90KSA9PiB7XHJcbiAgICAgIGNvbnN0IGRyYWZ0czogRmlyZWJhc2VEcmFmdERhdGFbXSA9IFtdXHJcbiAgICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XHJcbiAgICAgICAgZHJhZnRzLnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgICAgIC4uLmRvYy5kYXRhKClcclxuICAgICAgICB9IGFzIEZpcmViYXNlRHJhZnREYXRhKVxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgLy8gU29ydCBieSBsYXN0U2F2ZWQgaW4gbWVtb3J5IHRvIGF2b2lkIG5lZWRpbmcgYSBjb21wb3NpdGUgaW5kZXhcclxuICAgICAgY29uc3Qgc29ydGVkRHJhZnRzID0gZHJhZnRzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCBhVGltZSA9IGEubGFzdFNhdmVkPy50b0RhdGU/LigpPy5nZXRUaW1lKCkgfHwgMFxyXG4gICAgICAgIGNvbnN0IGJUaW1lID0gYi5sYXN0U2F2ZWQ/LnRvRGF0ZT8uKCk/LmdldFRpbWUoKSB8fCAwXHJcbiAgICAgICAgcmV0dXJuIGJUaW1lIC0gYVRpbWUgLy8gRGVzYyBvcmRlclxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgY2FsbGJhY2soc29ydGVkRHJhZnRzKVxyXG4gICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWwtdGltZSBkcmFmdHMgbGlzdGVuZXIgZXJyb3I6JywgZXJyb3IpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHVwIHJlYWwtdGltZSBsaXN0ZW5lciBmb3IgYSBzcGVjaWZpYyBkcmFmdFxyXG4gICAqL1xyXG4gIHN0YXRpYyBvbkRyYWZ0Q2hhbmdlKGRyYWZ0SWQ6IHN0cmluZywgY2FsbGJhY2s6IChkcmFmdDogRmlyZWJhc2VEcmFmdERhdGEgfCBudWxsKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XHJcbiAgICBjb25zdCBkcmFmdFJlZiA9IGRvYyhkYiwgdGhpcy5DT0xMRUNUSU9OX05BTUUsIGRyYWZ0SWQpXHJcbiAgICBcclxuICAgIHJldHVybiBvblNuYXBzaG90KGRyYWZ0UmVmLCAoZG9jKSA9PiB7XHJcbiAgICAgIGlmIChkb2MuZXhpc3RzKCkpIHtcclxuICAgICAgICBjYWxsYmFjayh7XHJcbiAgICAgICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgICAgIH0gYXMgRmlyZWJhc2VEcmFmdERhdGEpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FsbGJhY2sobnVsbClcclxuICAgICAgfVxyXG4gICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlYWwtdGltZSBkcmFmdCBsaXN0ZW5lciBlcnJvcjonLCBlcnJvcilcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGxvYWQgaW1hZ2UgdG8gRmlyZWJhc2UgU3RvcmFnZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIHVwbG9hZEltYWdlKGZpbGU6IEZpbGUsIGRyYWZ0SWQ6IHN0cmluZyk6IFByb21pc2U8eyBkb3dubG9hZFVybDogc3RyaW5nLCBzdG9yYWdlUGF0aDogc3RyaW5nIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0b3JhZ2VQYXRoID0gYCR7dGhpcy5TVE9SQUdFX1BBVEh9LyR7ZHJhZnRJZH0vJHtmaWxlLm5hbWV9YFxyXG4gICAgICBjb25zdCBpbWFnZVJlZiA9IHJlZihzdG9yYWdlLCBzdG9yYWdlUGF0aClcclxuICAgICAgXHJcbiAgICAgIGF3YWl0IHVwbG9hZEJ5dGVzKGltYWdlUmVmLCBmaWxlKVxyXG4gICAgICBjb25zdCBkb3dubG9hZFVybCA9IGF3YWl0IGdldERvd25sb2FkVVJMKGltYWdlUmVmKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHsgZG93bmxvYWRVcmwsIHN0b3JhZ2VQYXRoIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgaW1hZ2U6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBpbWFnZScpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWxldGUgaW1hZ2UgZnJvbSBGaXJlYmFzZSBTdG9yYWdlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZGVsZXRlSW1hZ2Uoc3RvcmFnZVBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgaW1hZ2VSZWYgPSByZWYoc3RvcmFnZSwgc3RvcmFnZVBhdGgpXHJcbiAgICAgIGF3YWl0IGRlbGV0ZU9iamVjdChpbWFnZVJlZilcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgaW1hZ2U6JywgZXJyb3IpXHJcbiAgICAgIC8vIERvbid0IHRocm93IGVycm9yIGFzIHRoaXMgaXMgY2xlYW51cFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgdW5pcXVlIGRyYWZ0IElEXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJhdGVEcmFmdElkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gYGRyYWZ0XyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlncmF0ZSBleGlzdGluZyBsb2NhbFN0b3JhZ2UgZHJhZnRzIHRvIEZpcmViYXNlXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIG1pZ3JhdGVMb2NhbERyYWZ0cygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEltcG9ydCB0aGUgZXhpc3RpbmcgZHJhZnQgc3RvcmFnZSB0byBhY2Nlc3MgbG9jYWwgZHJhZnRzXHJcbiAgICAgIGNvbnN0IHsgRHJhZnRTdG9yYWdlVjIgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXRpbHMvZHJhZnRTdG9yYWdlLnYyJylcclxuICAgICAgY29uc3QgbG9jYWxEcmFmdHMgPSBEcmFmdFN0b3JhZ2VWMi5nZXRBbGxEcmFmdHMoKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7bG9jYWxEcmFmdHMubGVuZ3RofSBsb2NhbCBkcmFmdHMgdG8gbWlncmF0ZWApXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IGxvY2FsRHJhZnQgb2YgbG9jYWxEcmFmdHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZmlyZWJhc2VEcmFmdDogUGFydGlhbDxGaXJlYmFzZURyYWZ0RGF0YT4gPSB7XHJcbiAgICAgICAgICAgIGRyYWZ0SWQ6IGxvY2FsRHJhZnQuZHJhZnRJZCxcclxuICAgICAgICAgICAgY3JlYXRpdmVGaWxlbmFtZTogbG9jYWxEcmFmdC5jcmVhdGl2ZUZpbGVuYW1lLFxyXG4gICAgICAgICAgICBmb3JtRGF0YTogbG9jYWxEcmFmdC5mb3JtRGF0YSxcclxuICAgICAgICAgICAgYXV0b1NhdmVkOiBsb2NhbERyYWZ0LmF1dG9TYXZlZCxcclxuICAgICAgICAgICAgdmVyc2lvbjogMSxcclxuICAgICAgICAgICAgaXNBY3RpdmU6IHRydWVcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgYXdhaXQgdGhpcy5zYXZlRHJhZnQoZmlyZWJhc2VEcmFmdClcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBNaWdyYXRlZCBkcmFmdDogJHtsb2NhbERyYWZ0LmNyZWF0aXZlRmlsZW5hbWV9YClcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIG1pZ3JhdGUgZHJhZnQgJHtsb2NhbERyYWZ0LmRyYWZ0SWR9OmAsIGVycm9yKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0RyYWZ0IG1pZ3JhdGlvbiBjb21wbGV0ZWQnKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIG1pZ3JhdGUgbG9jYWwgZHJhZnRzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHJlYWwtdGltZSB0cmFja2luZyBzdGF0aXN0aWNzXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGdldFRyYWNraW5nU3RhdHModXNlcklkOiBzdHJpbmcgPSAnYW5vbnltb3VzJyk6IFByb21pc2U8e1xyXG4gICAgdG90YWxEcmFmdHM6IG51bWJlclxyXG4gICAgYXV0b1NhdmVkQ291bnQ6IG51bWJlclxyXG4gICAgbWFudWFsU2F2ZWRDb3VudDogbnVtYmVyXHJcbiAgICBhaVBvcHVsYXRlZENvdW50OiBudW1iZXJcclxuICB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkcmFmdHMgPSBhd2FpdCB0aGlzLmdldEFsbERyYWZ0cyh1c2VySWQpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgICB0b3RhbERyYWZ0czogZHJhZnRzLmxlbmd0aCxcclxuICAgICAgICBhdXRvU2F2ZWRDb3VudDogZHJhZnRzLmZpbHRlcihkID0+IGQuYXV0b1NhdmVkKS5sZW5ndGgsXHJcbiAgICAgICAgbWFudWFsU2F2ZWRDb3VudDogZHJhZnRzLmZpbHRlcihkID0+ICFkLmF1dG9TYXZlZCkubGVuZ3RoLFxyXG4gICAgICAgIGFpUG9wdWxhdGVkQ291bnQ6IGRyYWZ0cy5maWx0ZXIoZCA9PiBkLmFpUG9wdWxhdGVkRmllbGRzICYmIGQuYWlQb3B1bGF0ZWRGaWVsZHMubGVuZ3RoID4gMCkubGVuZ3RoXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBzdGF0c1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCB0cmFja2luZyBzdGF0czonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbERyYWZ0czogMCxcclxuICAgICAgICBhdXRvU2F2ZWRDb3VudDogMCxcclxuICAgICAgICBtYW51YWxTYXZlZENvdW50OiAwLFxyXG4gICAgICAgIGFpUG9wdWxhdGVkQ291bnQ6IDBcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJjb2xsZWN0aW9uIiwiZG9jIiwiYWRkRG9jIiwidXBkYXRlRG9jIiwiZ2V0RG9jcyIsImdldERvYyIsIm9uU25hcHNob3QiLCJxdWVyeSIsIndoZXJlIiwic2VydmVyVGltZXN0YW1wIiwicmVmIiwidXBsb2FkQnl0ZXMiLCJnZXREb3dubG9hZFVSTCIsImRlbGV0ZU9iamVjdCIsImRiIiwic3RvcmFnZSIsIkZpcmViYXNlRHJhZnRTZXJ2aWNlIiwidGVzdENvbm5lY3Rpb24iLCJjb25zb2xlIiwibG9nIiwicSIsIkNPTExFQ1RJT05fTkFNRSIsImVycm9yIiwiY2xlYW5PYmplY3QiLCJvYmoiLCJ1bmRlZmluZWQiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJpdGVtIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJjbGVhbmVkIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJ2YWx1ZSIsInNhdmVEcmFmdCIsImRhdGEiLCJpbWFnZUZpbGUiLCJjbGVhbkZvcm1EYXRhIiwiZm9ybURhdGEiLCJ1cGxvYWRlZEltYWdlIiwiZmlsZSIsIm5hbWUiLCJzaXplIiwidHlwZSIsImxhc3RNb2RpZmllZCIsImlzRmlsZU9iamVjdCIsImRyYWZ0RGF0YSIsImRyYWZ0SWQiLCJnZW5lcmF0ZURyYWZ0SWQiLCJjcmVhdGl2ZUZpbGVuYW1lIiwibGFzdFNhdmVkIiwiYXV0b1NhdmVkIiwiYWlQb3B1bGF0ZWRGaWVsZHMiLCJ2ZXJzaW9uIiwiaXNBY3RpdmUiLCJ1c2VySWQiLCJpbWFnZURhdGEiLCJ1cGxvYWRJbWFnZSIsImltYWdlVXJsIiwiZG93bmxvYWRVcmwiLCJpbWFnZVN0b3JhZ2VQYXRoIiwic3RvcmFnZVBhdGgiLCJpbWFnZUVycm9yIiwid2FybiIsImlkIiwiZHJhZnRSZWYiLCJjcmVhdGVkQXQiLCJkb2NSZWYiLCJFcnJvciIsImdldERyYWZ0IiwiZHJhZnRTbmFwIiwiZXhpc3RzIiwiZ2V0QWxsRHJhZnRzIiwicXVlcnlTbmFwc2hvdCIsImRyYWZ0cyIsImZvckVhY2giLCJwdXNoIiwic29ydCIsImEiLCJiIiwiYVRpbWUiLCJ0b0RhdGUiLCJnZXRUaW1lIiwiYlRpbWUiLCJkZWxldGVEcmFmdCIsImRlbGV0ZUltYWdlIiwib25EcmFmdHNDaGFuZ2UiLCJjYWxsYmFjayIsInNvcnRlZERyYWZ0cyIsIm9uRHJhZnRDaGFuZ2UiLCJTVE9SQUdFX1BBVEgiLCJpbWFnZVJlZiIsIk1hdGgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJtaWdyYXRlTG9jYWxEcmFmdHMiLCJEcmFmdFN0b3JhZ2VWMiIsImxvY2FsRHJhZnRzIiwibGVuZ3RoIiwibG9jYWxEcmFmdCIsImZpcmViYXNlRHJhZnQiLCJnZXRUcmFja2luZ1N0YXRzIiwic3RhdHMiLCJ0b3RhbERyYWZ0cyIsImF1dG9TYXZlZENvdW50IiwiZmlsdGVyIiwiZCIsIm1hbnVhbFNhdmVkQ291bnQiLCJhaVBvcHVsYXRlZENvdW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firebase-draft-service.ts\n"));

/***/ })

});