"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/upload/single/page",{

/***/ "(app-pages-browser)/./lib/firebase-draft-service.ts":
/*!***************************************!*\
  !*** ./lib/firebase-draft-service.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseDraftService: () => (/* binding */ FirebaseDraftService)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n// Firebase Draft Service - Real-time draft management with Firestore\n\n\n\nclass FirebaseDraftService {\n    /**\r\n   * Test Firebase connection\r\n   */ static async testConnection() {\n        try {\n            console.log('🔥 Testing Firebase connection...');\n            // Try to read from Firestore\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            console.log('✅ Firebase connection test successful');\n            return true;\n        } catch (error) {\n            console.error('❌ Firebase connection test failed:', error);\n            return false;\n        }\n    }\n    /**\r\n   * Save or update a draft in Firestore\r\n   */ static async saveDraft(data, imageFile) {\n        try {\n            console.log('🔥 Firebase saveDraft called with data:', data);\n            // Clean the formData to remove non-serializable objects like File\n            const cleanFormData = {\n                ...data.formData\n            };\n            if (cleanFormData.uploadedImage) {\n                // Store only file metadata, not the actual File object\n                const file = cleanFormData.uploadedImage;\n                cleanFormData.uploadedImage = {\n                    name: file.name,\n                    size: file.size,\n                    type: file.type,\n                    lastModified: file.lastModified,\n                    isFileObject: true // Flag to identify this was a file\n                };\n            }\n            const draftData = {\n                draftId: data.draftId || this.generateDraftId(),\n                creativeFilename: data.creativeFilename || 'Untitled',\n                lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                autoSaved: data.autoSaved || false,\n                formData: cleanFormData,\n                aiPopulatedFields: data.aiPopulatedFields || [],\n                version: (data.version || 0) + 1,\n                isActive: true,\n                userId: data.userId || 'anonymous' // In production, use actual user ID\n            };\n            console.log('🔥 Prepared draft data for Firebase:', draftData);\n            // Handle image upload if provided (skip if storage permission issues)\n            if (imageFile) {\n                try {\n                    const imageData = await this.uploadImage(imageFile, draftData.draftId);\n                    draftData.imageUrl = imageData.downloadUrl;\n                    draftData.imageStoragePath = imageData.storagePath;\n                    console.log('✅ Image uploaded successfully');\n                } catch (imageError) {\n                    console.warn('⚠️ Image upload failed, continuing without image:', imageError);\n                // Don't fail the entire draft save if image upload fails\n                }\n            }\n            // If draftId exists, update existing document\n            if (data.id) {\n                console.log('🔥 Updating existing draft with ID:', data.id);\n                const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, data.id);\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(draftRef, {\n                    ...draftData,\n                    lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                });\n                console.log('✅ Draft updated successfully:', data.id);\n                return data.id;\n            } else {\n                // Create new draft\n                console.log('🔥 Creating new draft document');\n                draftData.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)();\n                const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), draftData);\n                console.log('✅ New draft created with ID:', docRef.id);\n                return docRef.id;\n            }\n        } catch (error) {\n            console.error('❌ Failed to save draft to Firebase:', error);\n            console.error('Firebase error details:', error);\n            throw new Error(\"Failed to save draft: \".concat(error));\n        }\n    }\n    /**\r\n   * Get a single draft by ID\r\n   */ static async getDraft(id) {\n        try {\n            const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, id);\n            const draftSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(draftRef);\n            if (draftSnap.exists()) {\n                return {\n                    id: draftSnap.id,\n                    ...draftSnap.data()\n                };\n            }\n            return null;\n        } catch (error) {\n            console.error('Failed to get draft:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Get all active drafts for a user\r\n   */ static async getAllDrafts() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous';\n        try {\n            // Simplified query to avoid needing a composite index\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const drafts = [];\n            querySnapshot.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            // Sort by lastSaved in memory to avoid needing a composite index\n            return drafts.sort((a, b)=>{\n                var _a_lastSaved_toDate, _a_lastSaved_toDate1, _a_lastSaved, _b_lastSaved_toDate, _b_lastSaved_toDate1, _b_lastSaved;\n                const aTime = ((_a_lastSaved = a.lastSaved) === null || _a_lastSaved === void 0 ? void 0 : (_a_lastSaved_toDate1 = _a_lastSaved.toDate) === null || _a_lastSaved_toDate1 === void 0 ? void 0 : (_a_lastSaved_toDate = _a_lastSaved_toDate1.call(_a_lastSaved)) === null || _a_lastSaved_toDate === void 0 ? void 0 : _a_lastSaved_toDate.getTime()) || 0;\n                const bTime = ((_b_lastSaved = b.lastSaved) === null || _b_lastSaved === void 0 ? void 0 : (_b_lastSaved_toDate1 = _b_lastSaved.toDate) === null || _b_lastSaved_toDate1 === void 0 ? void 0 : (_b_lastSaved_toDate = _b_lastSaved_toDate1.call(_b_lastSaved)) === null || _b_lastSaved_toDate === void 0 ? void 0 : _b_lastSaved_toDate.getTime()) || 0;\n                return bTime - aTime // Desc order\n                ;\n            });\n        } catch (error) {\n            console.error('Failed to get drafts:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Delete a draft (soft delete by marking as inactive)\r\n   */ static async deleteDraft(id) {\n        try {\n            const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, id);\n            // Get draft data to clean up image if needed\n            const draftSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(draftRef);\n            if (draftSnap.exists()) {\n                const draftData = draftSnap.data();\n                // Delete image from storage if exists\n                if (draftData.imageStoragePath) {\n                    await this.deleteImage(draftData.imageStoragePath);\n                }\n            }\n            // Soft delete by marking as inactive\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(draftRef, {\n                isActive: false,\n                lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            });\n            return true;\n        } catch (error) {\n            console.error('Failed to delete draft:', error);\n            return false;\n        }\n    }\n    /**\r\n   * Set up real-time listener for drafts\r\n   */ static onDraftsChange() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous', callback = arguments.length > 1 ? arguments[1] : void 0;\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)('lastSaved', 'desc'));\n        return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot)(q, (querySnapshot)=>{\n            const drafts = [];\n            querySnapshot.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            callback(drafts);\n        }, (error)=>{\n            console.error('Real-time drafts listener error:', error);\n        });\n    }\n    /**\r\n   * Set up real-time listener for a specific draft\r\n   */ static onDraftChange(draftId, callback) {\n        const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, draftId);\n        return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot)(draftRef, (doc)=>{\n            if (doc.exists()) {\n                callback({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            } else {\n                callback(null);\n            }\n        }, (error)=>{\n            console.error('Real-time draft listener error:', error);\n        });\n    }\n    /**\r\n   * Upload image to Firebase Storage\r\n   */ static async uploadImage(file, draftId) {\n        try {\n            const storagePath = \"\".concat(this.STORAGE_PATH, \"/\").concat(draftId, \"/\").concat(file.name);\n            const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, storagePath);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.uploadBytes)(imageRef, file);\n            const downloadUrl = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.getDownloadURL)(imageRef);\n            return {\n                downloadUrl,\n                storagePath\n            };\n        } catch (error) {\n            console.error('Failed to upload image:', error);\n            throw new Error('Failed to upload image');\n        }\n    }\n    /**\r\n   * Delete image from Firebase Storage\r\n   */ static async deleteImage(storagePath) {\n        try {\n            const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, storagePath);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.deleteObject)(imageRef);\n        } catch (error) {\n            console.error('Failed to delete image:', error);\n        // Don't throw error as this is cleanup\n        }\n    }\n    /**\r\n   * Generate unique draft ID\r\n   */ static generateDraftId() {\n        return \"draft_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    /**\r\n   * Migrate existing localStorage drafts to Firebase\r\n   */ static async migrateLocalDrafts() {\n        try {\n            // Import the existing draft storage to access local drafts\n            const { DraftStorageV2 } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_utils_draftStorage_v2_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../utils/draftStorage.v2 */ \"(app-pages-browser)/./utils/draftStorage.v2.ts\"));\n            const localDrafts = DraftStorageV2.getAllDrafts();\n            console.log(\"Found \".concat(localDrafts.length, \" local drafts to migrate\"));\n            for (const localDraft of localDrafts){\n                try {\n                    const firebaseDraft = {\n                        draftId: localDraft.draftId,\n                        creativeFilename: localDraft.creativeFilename,\n                        formData: localDraft.formData,\n                        autoSaved: localDraft.autoSaved,\n                        version: 1,\n                        isActive: true\n                    };\n                    await this.saveDraft(firebaseDraft);\n                    console.log(\"Migrated draft: \".concat(localDraft.creativeFilename));\n                } catch (error) {\n                    console.error(\"Failed to migrate draft \".concat(localDraft.draftId, \":\"), error);\n                }\n            }\n            console.log('Draft migration completed');\n        } catch (error) {\n            console.error('Failed to migrate local drafts:', error);\n        }\n    }\n    /**\r\n   * Get real-time tracking statistics\r\n   */ static async getTrackingStats() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous';\n        try {\n            const drafts = await this.getAllDrafts(userId);\n            const stats = {\n                totalDrafts: drafts.length,\n                autoSavedCount: drafts.filter((d)=>d.autoSaved).length,\n                manualSavedCount: drafts.filter((d)=>!d.autoSaved).length,\n                aiPopulatedCount: drafts.filter((d)=>d.aiPopulatedFields && d.aiPopulatedFields.length > 0).length\n            };\n            return stats;\n        } catch (error) {\n            console.error('Failed to get tracking stats:', error);\n            return {\n                totalDrafts: 0,\n                autoSavedCount: 0,\n                manualSavedCount: 0,\n                aiPopulatedCount: 0\n            };\n        }\n    }\n}\nFirebaseDraftService.COLLECTION_NAME = 'drafts';\nFirebaseDraftService.STORAGE_PATH = 'draft-images';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9maXJlYmFzZS1kcmFmdC1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxxRUFBcUU7QUFlMUM7QUFDc0Q7QUFDekM7QUFtQmpDLE1BQU1pQjtJQUlYOztHQUVDLEdBQ0QsYUFBYUMsaUJBQW1DO1FBQzlDLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osNkJBQTZCO1lBQzdCLE1BQU1DLElBQUlkLHlEQUFLQSxDQUFDUCw4REFBVUEsQ0FBQ2UseUNBQUVBLEVBQUUsSUFBSSxDQUFDTyxlQUFlLEdBQUdkLHlEQUFLQSxDQUFDLFlBQVksTUFBTTtZQUM5RSxNQUFNSiwyREFBT0EsQ0FBQ2lCO1lBQ2RGLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU87UUFDVCxFQUFFLE9BQU9HLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLHNDQUFzQ0E7WUFDcEQsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELGFBQWFDLFVBQVVDLElBQWdDLEVBQUVDLFNBQWdCLEVBQW1CO1FBQzFGLElBQUk7WUFDRlAsUUFBUUMsR0FBRyxDQUFDLDJDQUEyQ0s7WUFFdkQsa0VBQWtFO1lBQ2xFLE1BQU1FLGdCQUFnQjtnQkFBRSxHQUFHRixLQUFLRyxRQUFRO1lBQUM7WUFDekMsSUFBSUQsY0FBY0UsYUFBYSxFQUFFO2dCQUMvQix1REFBdUQ7Z0JBQ3ZELE1BQU1DLE9BQU9ILGNBQWNFLGFBQWE7Z0JBQ3hDRixjQUFjRSxhQUFhLEdBQUc7b0JBQzVCRSxNQUFNRCxLQUFLQyxJQUFJO29CQUNmQyxNQUFNRixLQUFLRSxJQUFJO29CQUNmQyxNQUFNSCxLQUFLRyxJQUFJO29CQUNmQyxjQUFjSixLQUFLSSxZQUFZO29CQUMvQkMsY0FBYyxLQUFLLG1DQUFtQztnQkFDeEQ7WUFDRjtZQUVBLE1BQU1DLFlBQXdDO2dCQUM1Q0MsU0FBU1osS0FBS1ksT0FBTyxJQUFJLElBQUksQ0FBQ0MsZUFBZTtnQkFDN0NDLGtCQUFr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QyxPQUFPaUMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLLENBQUNBLEVBQUV6RCxTQUFTLEVBQUVpRCxNQUFNO2dCQUN6RFUsa0JBQWtCcEMsT0FBT2lDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXhELGlCQUFpQixJQUFJd0QsRUFBRXhELGlCQUFpQixDQUFDZ0QsTUFBTSxHQUFHLEdBQUdBLE1BQU07WUFDcEc7WUFFQSxPQUFPSTtRQUNULEVBQUUsT0FBT3ZFLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLGlDQUFpQ0E7WUFDL0MsT0FBTztnQkFDTHdFLGFBQWE7Z0JBQ2JDLGdCQUFnQjtnQkFDaEJHLGtCQUFrQjtnQkFDbEJDLGtCQUFrQjtZQUNwQjtRQUNGO0lBQ0Y7QUFDRjtBQXhVYW5GLHFCQUNhSyxrQkFBa0I7QUFEL0JMLHFCQUVhOEQsZUFBZSIsInNvdXJjZXMiOlsiRDpcXElzdGlhbiBGaWxlc1xcVGlzZWdcXENSWSBBcHBcXGxpYlxcZmlyZWJhc2UtZHJhZnQtc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaXJlYmFzZSBEcmFmdCBTZXJ2aWNlIC0gUmVhbC10aW1lIGRyYWZ0IG1hbmFnZW1lbnQgd2l0aCBGaXJlc3RvcmVcclxuaW1wb3J0IHsgXHJcbiAgY29sbGVjdGlvbiwgXHJcbiAgZG9jLCBcclxuICBhZGREb2MsIFxyXG4gIHVwZGF0ZURvYywgXHJcbiAgZGVsZXRlRG9jLCBcclxuICBnZXREb2NzLCBcclxuICBnZXREb2MsXHJcbiAgb25TbmFwc2hvdCxcclxuICBxdWVyeSxcclxuICB3aGVyZSxcclxuICBvcmRlckJ5LFxyXG4gIFRpbWVzdGFtcCxcclxuICBzZXJ2ZXJUaW1lc3RhbXBcclxufSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnXHJcbmltcG9ydCB7IHJlZiwgdXBsb2FkQnl0ZXMsIGdldERvd25sb2FkVVJMLCBkZWxldGVPYmplY3QgfSBmcm9tICdmaXJlYmFzZS9zdG9yYWdlJ1xyXG5pbXBvcnQgeyBkYiwgc3RvcmFnZSB9IGZyb20gJy4vZmlyZWJhc2UnXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZpcmViYXNlRHJhZnREYXRhIHtcclxuICBpZD86IHN0cmluZ1xyXG4gIGRyYWZ0SWQ6IHN0cmluZ1xyXG4gIGNyZWF0aXZlRmlsZW5hbWU6IHN0cmluZ1xyXG4gIGxhc3RTYXZlZDogVGltZXN0YW1wXHJcbiAgY3JlYXRlZEF0OiBUaW1lc3RhbXBcclxuICBhdXRvU2F2ZWQ/OiBib29sZWFuXHJcbiAgZm9ybURhdGE6IGFueVxyXG4gIGltYWdlVXJsPzogc3RyaW5nXHJcbiAgaW1hZ2VTdG9yYWdlUGF0aD86IHN0cmluZ1xyXG4gIHVzZXJJZD86IHN0cmluZ1xyXG4gIC8vIEFkZGl0aW9uYWwgdHJhY2tpbmcgZmllbGRzIGFzIHBlciByZXF1aXJlbWVudHNcclxuICBhaVBvcHVsYXRlZEZpZWxkcz86IHN0cmluZ1tdXHJcbiAgdmVyc2lvbjogbnVtYmVyXHJcbiAgaXNBY3RpdmU6IGJvb2xlYW5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEZpcmViYXNlRHJhZnRTZXJ2aWNlIHtcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBDT0xMRUNUSU9OX05BTUUgPSAnZHJhZnRzJ1xyXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNUT1JBR0VfUEFUSCA9ICdkcmFmdC1pbWFnZXMnXHJcblxyXG4gIC8qKlxyXG4gICAqIFRlc3QgRmlyZWJhc2UgY29ubmVjdGlvblxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyB0ZXN0Q29ubmVjdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SlIFRlc3RpbmcgRmlyZWJhc2UgY29ubmVjdGlvbi4uLicpXHJcbiAgICAgIC8vIFRyeSB0byByZWFkIGZyb20gRmlyZXN0b3JlXHJcbiAgICAgIGNvbnN0IHEgPSBxdWVyeShjb2xsZWN0aW9uKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSksIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpKVxyXG4gICAgICBhd2FpdCBnZXREb2NzKHEpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRmlyZWJhc2UgY29ubmVjdGlvbiB0ZXN0IHN1Y2Nlc3NmdWwnKVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZpcmViYXNlIGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2F2ZSBvciB1cGRhdGUgYSBkcmFmdCBpbiBGaXJlc3RvcmVcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgc2F2ZURyYWZ0KGRhdGE6IFBhcnRpYWw8RmlyZWJhc2VEcmFmdERhdGE+LCBpbWFnZUZpbGU/OiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SlIEZpcmViYXNlIHNhdmVEcmFmdCBjYWxsZWQgd2l0aCBkYXRhOicsIGRhdGEpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhbiB0aGUgZm9ybURhdGEgdG8gcmVtb3ZlIG5vbi1zZXJpYWxpemFibGUgb2JqZWN0cyBsaWtlIEZpbGVcclxuICAgICAgY29uc3QgY2xlYW5Gb3JtRGF0YSA9IHsgLi4uZGF0YS5mb3JtRGF0YSB9XHJcbiAgICAgIGlmIChjbGVhbkZvcm1EYXRhLnVwbG9hZGVkSW1hZ2UpIHtcclxuICAgICAgICAvLyBTdG9yZSBvbmx5IGZpbGUgbWV0YWRhdGEsIG5vdCB0aGUgYWN0dWFsIEZpbGUgb2JqZWN0XHJcbiAgICAgICAgY29uc3QgZmlsZSA9IGNsZWFuRm9ybURhdGEudXBsb2FkZWRJbWFnZSBhcyBGaWxlXHJcbiAgICAgICAgY2xlYW5Gb3JtRGF0YS51cGxvYWRlZEltYWdlID0ge1xyXG4gICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxyXG4gICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxyXG4gICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxyXG4gICAgICAgICAgbGFzdE1vZGlmaWVkOiBmaWxlLmxhc3RNb2RpZmllZCxcclxuICAgICAgICAgIGlzRmlsZU9iamVjdDogdHJ1ZSAvLyBGbGFnIHRvIGlkZW50aWZ5IHRoaXMgd2FzIGEgZmlsZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgZHJhZnREYXRhOiBQYXJ0aWFsPEZpcmViYXNlRHJhZnREYXRhPiA9IHtcclxuICAgICAgICBkcmFmdElkOiBkYXRhLmRyYWZ0SWQgfHwgdGhpcy5nZW5lcmF0ZURyYWZ0SWQoKSxcclxuICAgICAgICBjcmVhdGl2ZUZpbGVuYW1lOiBkYXRhLmNyZWF0aXZlRmlsZW5hbWUgfHwgJ1VudGl0bGVkJyxcclxuICAgICAgICBsYXN0U2F2ZWQ6IHNlcnZlclRpbWVzdGFtcCgpIGFzIFRpbWVzdGFtcCxcclxuICAgICAgICBhdXRvU2F2ZWQ6IGRhdGEuYXV0b1NhdmVkIHx8IGZhbHNlLFxyXG4gICAgICAgIGZvcm1EYXRhOiBjbGVhbkZvcm1EYXRhLFxyXG4gICAgICAgIGFpUG9wdWxhdGVkRmllbGRzOiBkYXRhLmFpUG9wdWxhdGVkRmllbGRzIHx8IFtdLFxyXG4gICAgICAgIHZlcnNpb246IChkYXRhLnZlcnNpb24gfHwgMCkgKyAxLFxyXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIHVzZXJJZDogZGF0YS51c2VySWQgfHwgJ2Fub255bW91cycgLy8gSW4gcHJvZHVjdGlvbiwgdXNlIGFjdHVhbCB1c2VyIElEXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SlIFByZXBhcmVkIGRyYWZ0IGRhdGEgZm9yIEZpcmViYXNlOicsIGRyYWZ0RGF0YSlcclxuXHJcbiAgICAgIC8vIEhhbmRsZSBpbWFnZSB1cGxvYWQgaWYgcHJvdmlkZWQgKHNraXAgaWYgc3RvcmFnZSBwZXJtaXNzaW9uIGlzc3VlcylcclxuICAgICAgaWYgKGltYWdlRmlsZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBhd2FpdCB0aGlzLnVwbG9hZEltYWdlKGltYWdlRmlsZSwgZHJhZnREYXRhLmRyYWZ0SWQhKVxyXG4gICAgICAgICAgZHJhZnREYXRhLmltYWdlVXJsID0gaW1hZ2VEYXRhLmRvd25sb2FkVXJsXHJcbiAgICAgICAgICBkcmFmdERhdGEuaW1hZ2VTdG9yYWdlUGF0aCA9IGltYWdlRGF0YS5zdG9yYWdlUGF0aFxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBJbWFnZSB1cGxvYWRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICAgIH0gY2F0Y2ggKGltYWdlRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEltYWdlIHVwbG9hZCBmYWlsZWQsIGNvbnRpbnVpbmcgd2l0aG91dCBpbWFnZTonLCBpbWFnZUVycm9yKVxyXG4gICAgICAgICAgLy8gRG9uJ3QgZmFpbCB0aGUgZW50aXJlIGRyYWZ0IHNhdmUgaWYgaW1hZ2UgdXBsb2FkIGZhaWxzXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBkcmFmdElkIGV4aXN0cywgdXBkYXRlIGV4aXN0aW5nIGRvY3VtZW50XHJcbiAgICAgIGlmIChkYXRhLmlkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflKUgVXBkYXRpbmcgZXhpc3RpbmcgZHJhZnQgd2l0aCBJRDonLCBkYXRhLmlkKVxyXG4gICAgICAgIGNvbnN0IGRyYWZ0UmVmID0gZG9jKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSwgZGF0YS5pZClcclxuICAgICAgICBhd2FpdCB1cGRhdGVEb2MoZHJhZnRSZWYsIHtcclxuICAgICAgICAgIC4uLmRyYWZ0RGF0YSxcclxuICAgICAgICAgIGxhc3RTYXZlZDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgICB9KVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgRHJhZnQgdXBkYXRlZCBzdWNjZXNzZnVsbHk6JywgZGF0YS5pZClcclxuICAgICAgICByZXR1cm4gZGF0YS5pZFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgZHJhZnRcclxuICAgICAgICBjb25zb2xlLmxvZygn8J+UpSBDcmVhdGluZyBuZXcgZHJhZnQgZG9jdW1lbnQnKVxyXG4gICAgICAgIGRyYWZ0RGF0YS5jcmVhdGVkQXQgPSBzZXJ2ZXJUaW1lc3RhbXAoKSBhcyBUaW1lc3RhbXBcclxuICAgICAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgdGhpcy5DT0xMRUNUSU9OX05BTUUpLCBkcmFmdERhdGEpXHJcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBOZXcgZHJhZnQgY3JlYXRlZCB3aXRoIElEOicsIGRvY1JlZi5pZClcclxuICAgICAgICByZXR1cm4gZG9jUmVmLmlkXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gc2F2ZSBkcmFmdCB0byBGaXJlYmFzZTonLCBlcnJvcilcclxuICAgICAgY29uc29sZS5lcnJvcignRmlyZWJhc2UgZXJyb3IgZGV0YWlsczonLCBlcnJvcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2F2ZSBkcmFmdDogJHtlcnJvcn1gKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGEgc2luZ2xlIGRyYWZ0IGJ5IElEXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGdldERyYWZ0KGlkOiBzdHJpbmcpOiBQcm9taXNlPEZpcmViYXNlRHJhZnREYXRhIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZHJhZnRSZWYgPSBkb2MoZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FLCBpZClcclxuICAgICAgY29uc3QgZHJhZnRTbmFwID0gYXdhaXQgZ2V0RG9jKGRyYWZ0UmVmKVxyXG4gICAgICBcclxuICAgICAgaWYgKGRyYWZ0U25hcC5leGlzdHMoKSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZDogZHJhZnRTbmFwLmlkLFxyXG4gICAgICAgICAgLi4uZHJhZnRTbmFwLmRhdGEoKVxyXG4gICAgICAgIH0gYXMgRmlyZWJhc2VEcmFmdERhdGFcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBkcmFmdDonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbGwgYWN0aXZlIGRyYWZ0cyBmb3IgYSB1c2VyXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGdldEFsbERyYWZ0cyh1c2VySWQ6IHN0cmluZyA9ICdhbm9ueW1vdXMnKTogUHJvbWlzZTxGaXJlYmFzZURyYWZ0RGF0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTaW1wbGlmaWVkIHF1ZXJ5IHRvIGF2b2lkIG5lZWRpbmcgYSBjb21wb3NpdGUgaW5kZXhcclxuICAgICAgY29uc3QgcSA9IHF1ZXJ5KFxyXG4gICAgICAgIGNvbGxlY3Rpb24oZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FKSxcclxuICAgICAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlcklkKSxcclxuICAgICAgICB3aGVyZSgnaXNBY3RpdmUnLCAnPT0nLCB0cnVlKVxyXG4gICAgICApXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKVxyXG4gICAgICBjb25zdCBkcmFmdHM6IEZpcmViYXNlRHJhZnREYXRhW10gPSBbXVxyXG4gICAgICBcclxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcclxuICAgICAgICBkcmFmdHMucHVzaCh7XHJcbiAgICAgICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgICAgIH0gYXMgRmlyZWJhc2VEcmFmdERhdGEpXHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICAvLyBTb3J0IGJ5IGxhc3RTYXZlZCBpbiBtZW1vcnkgdG8gYXZvaWQgbmVlZGluZyBhIGNvbXBvc2l0ZSBpbmRleFxyXG4gICAgICByZXR1cm4gZHJhZnRzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICBjb25zdCBhVGltZSA9IGEubGFzdFNhdmVkPy50b0RhdGU/LigpPy5nZXRUaW1lKCkgfHwgMFxyXG4gICAgICAgIGNvbnN0IGJUaW1lID0gYi5sYXN0U2F2ZWQ/LnRvRGF0ZT8uKCk/LmdldFRpbWUoKSB8fCAwXHJcbiAgICAgICAgcmV0dXJuIGJUaW1lIC0gYVRpbWUgLy8gRGVzYyBvcmRlclxyXG4gICAgICB9KVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBkcmFmdHM6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBbXVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGEgZHJhZnQgKHNvZnQgZGVsZXRlIGJ5IG1hcmtpbmcgYXMgaW5hY3RpdmUpXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGRlbGV0ZURyYWZ0KGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRyYWZ0UmVmID0gZG9jKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSwgaWQpXHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgZHJhZnQgZGF0YSB0byBjbGVhbiB1cCBpbWFnZSBpZiBuZWVkZWRcclxuICAgICAgY29uc3QgZHJhZnRTbmFwID0gYXdhaXQgZ2V0RG9jKGRyYWZ0UmVmKVxyXG4gICAgICBpZiAoZHJhZnRTbmFwLmV4aXN0cygpKSB7XHJcbiAgICAgICAgY29uc3QgZHJhZnREYXRhID0gZHJhZnRTbmFwLmRhdGEoKSBhcyBGaXJlYmFzZURyYWZ0RGF0YVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERlbGV0ZSBpbWFnZSBmcm9tIHN0b3JhZ2UgaWYgZXhpc3RzXHJcbiAgICAgICAgaWYgKGRyYWZ0RGF0YS5pbWFnZVN0b3JhZ2VQYXRoKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZUltYWdlKGRyYWZ0RGF0YS5pbWFnZVN0b3JhZ2VQYXRoKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU29mdCBkZWxldGUgYnkgbWFya2luZyBhcyBpbmFjdGl2ZVxyXG4gICAgICBhd2FpdCB1cGRhdGVEb2MoZHJhZnRSZWYsIHtcclxuICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgbGFzdFNhdmVkOiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHRydWVcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWxldGUgZHJhZnQ6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHVwIHJlYWwtdGltZSBsaXN0ZW5lciBmb3IgZHJhZnRzXHJcbiAgICovXHJcbiAgc3RhdGljIG9uRHJhZnRzQ2hhbmdlKHVzZXJJZDogc3RyaW5nID0gJ2Fub255bW91cycsIGNhbGxiYWNrOiAoZHJhZnRzOiBGaXJlYmFzZURyYWZ0RGF0YVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XHJcbiAgICBjb25zdCBxID0gcXVlcnkoXHJcbiAgICAgIGNvbGxlY3Rpb24oZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FKSxcclxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXHJcbiAgICAgIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpLFxyXG4gICAgICBvcmRlckJ5KCdsYXN0U2F2ZWQnLCAnZGVzYycpXHJcbiAgICApXHJcblxyXG4gICAgcmV0dXJuIG9uU25hcHNob3QocSwgKHF1ZXJ5U25hcHNob3QpID0+IHtcclxuICAgICAgY29uc3QgZHJhZnRzOiBGaXJlYmFzZURyYWZ0RGF0YVtdID0gW11cclxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcclxuICAgICAgICBkcmFmdHMucHVzaCh7XHJcbiAgICAgICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgICAgIH0gYXMgRmlyZWJhc2VEcmFmdERhdGEpXHJcbiAgICAgIH0pXHJcbiAgICAgIGNhbGxiYWNrKGRyYWZ0cylcclxuICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdSZWFsLXRpbWUgZHJhZnRzIGxpc3RlbmVyIGVycm9yOicsIGVycm9yKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB1cCByZWFsLXRpbWUgbGlzdGVuZXIgZm9yIGEgc3BlY2lmaWMgZHJhZnRcclxuICAgKi9cclxuICBzdGF0aWMgb25EcmFmdENoYW5nZShkcmFmdElkOiBzdHJpbmcsIGNhbGxiYWNrOiAoZHJhZnQ6IEZpcmViYXNlRHJhZnREYXRhIHwgbnVsbCkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xyXG4gICAgY29uc3QgZHJhZnRSZWYgPSBkb2MoZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FLCBkcmFmdElkKVxyXG4gICAgXHJcbiAgICByZXR1cm4gb25TbmFwc2hvdChkcmFmdFJlZiwgKGRvYykgPT4ge1xyXG4gICAgICBpZiAoZG9jLmV4aXN0cygpKSB7XHJcbiAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgICAgIC4uLmRvYy5kYXRhKClcclxuICAgICAgICB9IGFzIEZpcmViYXNlRHJhZnREYXRhKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNhbGxiYWNrKG51bGwpXHJcbiAgICAgIH1cclxuICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdSZWFsLXRpbWUgZHJhZnQgbGlzdGVuZXIgZXJyb3I6JywgZXJyb3IpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBsb2FkIGltYWdlIHRvIEZpcmViYXNlIFN0b3JhZ2VcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBhc3luYyB1cGxvYWRJbWFnZShmaWxlOiBGaWxlLCBkcmFmdElkOiBzdHJpbmcpOiBQcm9taXNlPHsgZG93bmxvYWRVcmw6IHN0cmluZywgc3RvcmFnZVBhdGg6IHN0cmluZyB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdG9yYWdlUGF0aCA9IGAke3RoaXMuU1RPUkFHRV9QQVRIfS8ke2RyYWZ0SWR9LyR7ZmlsZS5uYW1lfWBcclxuICAgICAgY29uc3QgaW1hZ2VSZWYgPSByZWYoc3RvcmFnZSwgc3RvcmFnZVBhdGgpXHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCB1cGxvYWRCeXRlcyhpbWFnZVJlZiwgZmlsZSlcclxuICAgICAgY29uc3QgZG93bmxvYWRVcmwgPSBhd2FpdCBnZXREb3dubG9hZFVSTChpbWFnZVJlZilcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7IGRvd25sb2FkVXJsLCBzdG9yYWdlUGF0aCB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGltYWdlOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgaW1hZ2UnKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlIGltYWdlIGZyb20gRmlyZWJhc2UgU3RvcmFnZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIGRlbGV0ZUltYWdlKHN0b3JhZ2VQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGltYWdlUmVmID0gcmVmKHN0b3JhZ2UsIHN0b3JhZ2VQYXRoKVxyXG4gICAgICBhd2FpdCBkZWxldGVPYmplY3QoaW1hZ2VSZWYpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGltYWdlOicsIGVycm9yKVxyXG4gICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciBhcyB0aGlzIGlzIGNsZWFudXBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIHVuaXF1ZSBkcmFmdCBJRFxyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RhdGljIGdlbmVyYXRlRHJhZnRJZCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGBkcmFmdF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pZ3JhdGUgZXhpc3RpbmcgbG9jYWxTdG9yYWdlIGRyYWZ0cyB0byBGaXJlYmFzZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBtaWdyYXRlTG9jYWxEcmFmdHMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJbXBvcnQgdGhlIGV4aXN0aW5nIGRyYWZ0IHN0b3JhZ2UgdG8gYWNjZXNzIGxvY2FsIGRyYWZ0c1xyXG4gICAgICBjb25zdCB7IERyYWZ0U3RvcmFnZVYyIH0gPSBhd2FpdCBpbXBvcnQoJy4uL3V0aWxzL2RyYWZ0U3RvcmFnZS52MicpXHJcbiAgICAgIGNvbnN0IGxvY2FsRHJhZnRzID0gRHJhZnRTdG9yYWdlVjIuZ2V0QWxsRHJhZnRzKClcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2xvY2FsRHJhZnRzLmxlbmd0aH0gbG9jYWwgZHJhZnRzIHRvIG1pZ3JhdGVgKVxyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCBsb2NhbERyYWZ0IG9mIGxvY2FsRHJhZnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGZpcmViYXNlRHJhZnQ6IFBhcnRpYWw8RmlyZWJhc2VEcmFmdERhdGE+ID0ge1xyXG4gICAgICAgICAgICBkcmFmdElkOiBsb2NhbERyYWZ0LmRyYWZ0SWQsXHJcbiAgICAgICAgICAgIGNyZWF0aXZlRmlsZW5hbWU6IGxvY2FsRHJhZnQuY3JlYXRpdmVGaWxlbmFtZSxcclxuICAgICAgICAgICAgZm9ybURhdGE6IGxvY2FsRHJhZnQuZm9ybURhdGEsXHJcbiAgICAgICAgICAgIGF1dG9TYXZlZDogbG9jYWxEcmFmdC5hdXRvU2F2ZWQsXHJcbiAgICAgICAgICAgIHZlcnNpb246IDEsXHJcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGF3YWl0IHRoaXMuc2F2ZURyYWZ0KGZpcmViYXNlRHJhZnQpXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgTWlncmF0ZWQgZHJhZnQ6ICR7bG9jYWxEcmFmdC5jcmVhdGl2ZUZpbGVuYW1lfWApXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBtaWdyYXRlIGRyYWZ0ICR7bG9jYWxEcmFmdC5kcmFmdElkfTpgLCBlcnJvcilcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdEcmFmdCBtaWdyYXRpb24gY29tcGxldGVkJylcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBtaWdyYXRlIGxvY2FsIGRyYWZ0czonLCBlcnJvcilcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCByZWFsLXRpbWUgdHJhY2tpbmcgc3RhdGlzdGljc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBnZXRUcmFja2luZ1N0YXRzKHVzZXJJZDogc3RyaW5nID0gJ2Fub255bW91cycpOiBQcm9taXNlPHtcclxuICAgIHRvdGFsRHJhZnRzOiBudW1iZXJcclxuICAgIGF1dG9TYXZlZENvdW50OiBudW1iZXJcclxuICAgIG1hbnVhbFNhdmVkQ291bnQ6IG51bWJlclxyXG4gICAgYWlQb3B1bGF0ZWRDb3VudDogbnVtYmVyXHJcbiAgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZHJhZnRzID0gYXdhaXQgdGhpcy5nZXRBbGxEcmFmdHModXNlcklkKVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3RhdHMgPSB7XHJcbiAgICAgICAgdG90YWxEcmFmdHM6IGRyYWZ0cy5sZW5ndGgsXHJcbiAgICAgICAgYXV0b1NhdmVkQ291bnQ6IGRyYWZ0cy5maWx0ZXIoZCA9PiBkLmF1dG9TYXZlZCkubGVuZ3RoLFxyXG4gICAgICAgIG1hbnVhbFNhdmVkQ291bnQ6IGRyYWZ0cy5maWx0ZXIoZCA9PiAhZC5hdXRvU2F2ZWQpLmxlbmd0aCxcclxuICAgICAgICBhaVBvcHVsYXRlZENvdW50OiBkcmFmdHMuZmlsdGVyKGQgPT4gZC5haVBvcHVsYXRlZEZpZWxkcyAmJiBkLmFpUG9wdWxhdGVkRmllbGRzLmxlbmd0aCA+IDApLmxlbmd0aFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gc3RhdHNcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgdHJhY2tpbmcgc3RhdHM6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG90YWxEcmFmdHM6IDAsXHJcbiAgICAgICAgYXV0b1NhdmVkQ291bnQ6IDAsXHJcbiAgICAgICAgbWFudWFsU2F2ZWRDb3VudDogMCxcclxuICAgICAgICBhaVBvcHVsYXRlZENvdW50OiAwXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0iXSwibmFtZXMiOlsiY29sbGVjdGlvbiIsImRvYyIsImFkZERvYyIsInVwZGF0ZURvYyIsImdldERvY3MiLCJnZXREb2MiLCJvblNuYXBzaG90IiwicXVlcnkiLCJ3aGVyZSIsIm9yZGVyQnkiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJyZWYiLCJ1cGxvYWRCeXRlcyIsImdldERvd25sb2FkVVJMIiwiZGVsZXRlT2JqZWN0IiwiZGIiLCJzdG9yYWdlIiwiRmlyZWJhc2VEcmFmdFNlcnZpY2UiLCJ0ZXN0Q29ubmVjdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJxIiwiQ09MTEVDVElPTl9OQU1FIiwiZXJyb3IiLCJzYXZlRHJhZnQiLCJkYXRhIiwiaW1hZ2VGaWxlIiwiY2xlYW5Gb3JtRGF0YSIsImZvcm1EYXRhIiwidXBsb2FkZWRJbWFnZSIsImZpbGUiLCJuYW1lIiwic2l6ZSIsInR5cGUiLCJsYXN0TW9kaWZpZWQiLCJpc0ZpbGVPYmplY3QiLCJkcmFmdERhdGEiLCJkcmFmdElkIiwiZ2VuZXJhdGVEcmFmdElkIiwiY3JlYXRpdmVGaWxlbmFtZSIsImxhc3RTYXZlZCIsImF1dG9TYXZlZCIsImFpUG9wdWxhdGVkRmllbGRzIiwidmVyc2lvbiIsImlzQWN0aXZlIiwidXNlcklkIiwiaW1hZ2VEYXRhIiwidXBsb2FkSW1hZ2UiLCJpbWFnZVVybCIsImRvd25sb2FkVXJsIiwiaW1hZ2VTdG9yYWdlUGF0aCIsInN0b3JhZ2VQYXRoIiwiaW1hZ2VFcnJvciIsIndhcm4iLCJpZCIsImRyYWZ0UmVmIiwiY3JlYXRlZEF0IiwiZG9jUmVmIiwiRXJyb3IiLCJnZXREcmFmdCIsImRyYWZ0U25hcCIsImV4aXN0cyIsImdldEFsbERyYWZ0cyIsInF1ZXJ5U25hcHNob3QiLCJkcmFmdHMiLCJmb3JFYWNoIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsImFUaW1lIiwidG9EYXRlIiwiZ2V0VGltZSIsImJUaW1lIiwiZGVsZXRlRHJhZnQiLCJkZWxldGVJbWFnZSIsIm9uRHJhZnRzQ2hhbmdlIiwiY2FsbGJhY2siLCJvbkRyYWZ0Q2hhbmdlIiwiU1RPUkFHRV9QQVRIIiwiaW1hZ2VSZWYiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwibWlncmF0ZUxvY2FsRHJhZnRzIiwiRHJhZnRTdG9yYWdlVjIiLCJsb2NhbERyYWZ0cyIsImxlbmd0aCIsImxvY2FsRHJhZnQiLCJmaXJlYmFzZURyYWZ0IiwiZ2V0VHJhY2tpbmdTdGF0cyIsInN0YXRzIiwidG90YWxEcmFmdHMiLCJhdXRvU2F2ZWRDb3VudCIsImZpbHRlciIsImQiLCJtYW51YWxTYXZlZENvdW50IiwiYWlQb3B1bGF0ZWRDb3VudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firebase-draft-service.ts\n"));

/***/ })

});