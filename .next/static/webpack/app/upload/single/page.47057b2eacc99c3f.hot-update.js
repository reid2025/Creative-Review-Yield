"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/upload/single/page",{

/***/ "(app-pages-browser)/./lib/firebase-draft-service.ts":
/*!***************************************!*\
  !*** ./lib/firebase-draft-service.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseDraftService: () => (/* binding */ FirebaseDraftService)\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n// Firebase Draft Service - Real-time draft management with Firestore\n\n\n\nclass FirebaseDraftService {\n    /**\r\n   * Test Firebase connection\r\n   */ static async testConnection() {\n        try {\n            // Testing Firebase connection\n            // Try to read from Firestore\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            // Firebase connection test successful\n            return true;\n        } catch (error) {\n            console.error('❌ Firebase connection test failed:', error);\n            return false;\n        }\n    }\n    /**\r\n   * Clean object to remove undefined values (Firebase doesn't accept undefined)\r\n   */ static cleanObject(obj) {\n        if (obj === null || obj === undefined) {\n            return null;\n        }\n        if (Array.isArray(obj)) {\n            return obj.map((item)=>this.cleanObject(item));\n        }\n        if (typeof obj === 'object' && obj.constructor === Object) {\n            const cleaned = {};\n            for(const key in obj){\n                if (obj.hasOwnProperty(key)) {\n                    const value = obj[key];\n                    if (value !== undefined) {\n                        cleaned[key] = this.cleanObject(value);\n                    }\n                }\n            }\n            return cleaned;\n        }\n        return obj;\n    }\n    /**\r\n   * Save or update a draft in Firestore\r\n   */ static async saveDraft(data, imageFile) {\n        try {\n            // Saving draft to Firebase\n            // Clean the formData to remove non-serializable objects like File and undefined values\n            const cleanFormData = this.cleanObject({\n                ...data.formData\n            });\n            if (cleanFormData && cleanFormData.uploadedImage) {\n                // Store only file metadata, not the actual File object\n                const file = cleanFormData.uploadedImage;\n                if (file && typeof file === 'object' && file.name) {\n                    cleanFormData.uploadedImage = {\n                        name: file.name,\n                        size: file.size,\n                        type: file.type,\n                        lastModified: file.lastModified,\n                        isFileObject: true // Flag to identify this was a file\n                    };\n                }\n            }\n            // Clean the entire draft data object to remove undefined values\n            const draftData = this.cleanObject({\n                draftId: data.draftId || this.generateDraftId(),\n                creativeFilename: data.creativeFilename || 'Untitled',\n                lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                autoSaved: data.autoSaved || false,\n                formData: cleanFormData || {},\n                aiPopulatedFields: data.aiPopulatedFields || [],\n                version: (data.version || 0) + 1,\n                isActive: true,\n                userId: data.userId || 'anonymous' // In production, use actual user ID\n            });\n            // Prepared draft data for Firebase\n            // Handle image upload if provided (skip if storage permission issues)\n            if (imageFile) {\n                try {\n                    const imageData = await this.uploadImage(imageFile, draftData.draftId);\n                    draftData.imageUrl = imageData.downloadUrl;\n                    draftData.imageStoragePath = imageData.storagePath;\n                // Image uploaded successfully\n                } catch (imageError) {\n                    console.warn('⚠️ Image upload failed, continuing without image:', imageError);\n                // Don't fail the entire draft save if image upload fails\n                }\n            }\n            // If draftId exists, update existing document\n            if (data.id) {\n                // Updating existing draft\n                const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, data.id);\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(draftRef, {\n                    ...draftData,\n                    lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n                });\n                // Draft updated successfully\n                return data.id;\n            } else {\n                // Create new draft\n                // Creating new draft document\n                draftData.createdAt = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)();\n                const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), draftData);\n                // New draft created\n                return docRef.id;\n            }\n        } catch (error) {\n            console.error('❌ Failed to save draft to Firebase:', error);\n            console.error('Firebase error details:', error);\n            throw new Error(\"Failed to save draft: \".concat(error));\n        }\n    }\n    /**\r\n   * Get a single draft by ID\r\n   */ static async getDraft(id) {\n        try {\n            const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, id);\n            const draftSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(draftRef);\n            if (draftSnap.exists()) {\n                return {\n                    id: draftSnap.id,\n                    ...draftSnap.data()\n                };\n            }\n            return null;\n        } catch (error) {\n            console.error('Failed to get draft:', error);\n            return null;\n        }\n    }\n    /**\r\n   * Get all active drafts for a user\r\n   */ static async getAllDrafts() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous';\n        try {\n            // Simplified query to avoid needing a composite index\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const drafts = [];\n            querySnapshot.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            // Sort by lastSaved in memory to avoid needing a composite index\n            return drafts.sort((a, b)=>{\n                var _a_lastSaved_toDate, _a_lastSaved_toDate1, _a_lastSaved, _b_lastSaved_toDate, _b_lastSaved_toDate1, _b_lastSaved;\n                const aTime = ((_a_lastSaved = a.lastSaved) === null || _a_lastSaved === void 0 ? void 0 : (_a_lastSaved_toDate1 = _a_lastSaved.toDate) === null || _a_lastSaved_toDate1 === void 0 ? void 0 : (_a_lastSaved_toDate = _a_lastSaved_toDate1.call(_a_lastSaved)) === null || _a_lastSaved_toDate === void 0 ? void 0 : _a_lastSaved_toDate.getTime()) || 0;\n                const bTime = ((_b_lastSaved = b.lastSaved) === null || _b_lastSaved === void 0 ? void 0 : (_b_lastSaved_toDate1 = _b_lastSaved.toDate) === null || _b_lastSaved_toDate1 === void 0 ? void 0 : (_b_lastSaved_toDate = _b_lastSaved_toDate1.call(_b_lastSaved)) === null || _b_lastSaved_toDate === void 0 ? void 0 : _b_lastSaved_toDate.getTime()) || 0;\n                return bTime - aTime // Desc order\n                ;\n            });\n        } catch (error) {\n            console.error('Failed to get drafts:', error);\n            return [];\n        }\n    }\n    /**\r\n   * Delete a draft (soft delete by marking as inactive)\r\n   */ static async deleteDraft(id) {\n        try {\n            const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, id);\n            // Get draft data to clean up image if needed\n            const draftSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(draftRef);\n            if (draftSnap.exists()) {\n                const draftData = draftSnap.data();\n                // Delete image from storage if exists\n                if (draftData.imageStoragePath) {\n                    await this.deleteImage(draftData.imageStoragePath);\n                }\n            }\n            // Soft delete by marking as inactive\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(draftRef, {\n                isActive: false,\n                lastSaved: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            });\n            return true;\n        } catch (error) {\n            console.error('Failed to delete draft:', error);\n            return false;\n        }\n    }\n    /**\r\n   * Set up real-time listener for drafts\r\n   */ static onDraftsChange() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous', callback = arguments.length > 1 ? arguments[1] : void 0;\n        // Simplified query to avoid needing a composite index\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('userId', '==', userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)('isActive', '==', true));\n        return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot)(q, (querySnapshot)=>{\n            const drafts = [];\n            querySnapshot.forEach((doc)=>{\n                drafts.push({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            });\n            // Sort by lastSaved in memory to avoid needing a composite index\n            const sortedDrafts = drafts.sort((a, b)=>{\n                var _a_lastSaved_toDate, _a_lastSaved_toDate1, _a_lastSaved, _b_lastSaved_toDate, _b_lastSaved_toDate1, _b_lastSaved;\n                const aTime = ((_a_lastSaved = a.lastSaved) === null || _a_lastSaved === void 0 ? void 0 : (_a_lastSaved_toDate1 = _a_lastSaved.toDate) === null || _a_lastSaved_toDate1 === void 0 ? void 0 : (_a_lastSaved_toDate = _a_lastSaved_toDate1.call(_a_lastSaved)) === null || _a_lastSaved_toDate === void 0 ? void 0 : _a_lastSaved_toDate.getTime()) || 0;\n                const bTime = ((_b_lastSaved = b.lastSaved) === null || _b_lastSaved === void 0 ? void 0 : (_b_lastSaved_toDate1 = _b_lastSaved.toDate) === null || _b_lastSaved_toDate1 === void 0 ? void 0 : (_b_lastSaved_toDate = _b_lastSaved_toDate1.call(_b_lastSaved)) === null || _b_lastSaved_toDate === void 0 ? void 0 : _b_lastSaved_toDate.getTime()) || 0;\n                return bTime - aTime // Desc order\n                ;\n            });\n            callback(sortedDrafts);\n        }, (error)=>{\n            console.error('Real-time drafts listener error:', error);\n        });\n    }\n    /**\r\n   * Set up real-time listener for a specific draft\r\n   */ static onDraftChange(draftId, callback) {\n        const draftRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, this.COLLECTION_NAME, draftId);\n        return (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.onSnapshot)(draftRef, (doc)=>{\n            if (doc.exists()) {\n                callback({\n                    id: doc.id,\n                    ...doc.data()\n                });\n            } else {\n                callback(null);\n            }\n        }, (error)=>{\n            console.error('Real-time draft listener error:', error);\n        });\n    }\n    /**\r\n   * Upload image to Firebase Storage\r\n   */ static async uploadImage(file, draftId) {\n        try {\n            const storagePath = \"\".concat(this.STORAGE_PATH, \"/\").concat(draftId, \"/\").concat(file.name);\n            const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, storagePath);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.uploadBytes)(imageRef, file);\n            const downloadUrl = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.getDownloadURL)(imageRef);\n            return {\n                downloadUrl,\n                storagePath\n            };\n        } catch (error) {\n            console.error('Failed to upload image:', error);\n            throw new Error('Failed to upload image');\n        }\n    }\n    /**\r\n   * Delete image from Firebase Storage\r\n   */ static async deleteImage(storagePath) {\n        try {\n            const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, storagePath);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.deleteObject)(imageRef);\n        } catch (error) {\n            console.error('Failed to delete image:', error);\n        // Don't throw error as this is cleanup\n        }\n    }\n    /**\r\n   * Generate unique draft ID\r\n   */ static generateDraftId() {\n        return \"draft_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    /**\r\n   * Migrate existing localStorage drafts to Firebase\r\n   */ static async migrateLocalDrafts() {\n        try {\n            // Import the existing draft storage to access local drafts\n            const { DraftStorageV2 } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_utils_draftStorage_v2_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ../utils/draftStorage.v2 */ \"(app-pages-browser)/./utils/draftStorage.v2.ts\"));\n            const localDrafts = DraftStorageV2.getAllDrafts();\n            console.log(\"Found \".concat(localDrafts.length, \" local drafts to migrate\"));\n            for (const localDraft of localDrafts){\n                try {\n                    const firebaseDraft = {\n                        draftId: localDraft.draftId,\n                        creativeFilename: localDraft.creativeFilename,\n                        formData: localDraft.formData,\n                        autoSaved: localDraft.autoSaved,\n                        version: 1,\n                        isActive: true\n                    };\n                    await this.saveDraft(firebaseDraft);\n                    console.log(\"Migrated draft: \".concat(localDraft.creativeFilename));\n                } catch (error) {\n                    console.error(\"Failed to migrate draft \".concat(localDraft.draftId, \":\"), error);\n                }\n            }\n            console.log('Draft migration completed');\n        } catch (error) {\n            console.error('Failed to migrate local drafts:', error);\n        }\n    }\n    /**\r\n   * Get real-time tracking statistics\r\n   */ static async getTrackingStats() {\n        let userId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'anonymous';\n        try {\n            const drafts = await this.getAllDrafts(userId);\n            const stats = {\n                totalDrafts: drafts.length,\n                autoSavedCount: drafts.filter((d)=>d.autoSaved).length,\n                manualSavedCount: drafts.filter((d)=>!d.autoSaved).length,\n                aiPopulatedCount: drafts.filter((d)=>d.aiPopulatedFields && d.aiPopulatedFields.length > 0).length\n            };\n            return stats;\n        } catch (error) {\n            console.error('Failed to get tracking stats:', error);\n            return {\n                totalDrafts: 0,\n                autoSavedCount: 0,\n                manualSavedCount: 0,\n                aiPopulatedCount: 0\n            };\n        }\n    }\n}\nFirebaseDraftService.COLLECTION_NAME = 'drafts';\nFirebaseDraftService.STORAGE_PATH = 'draft-images';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9maXJlYmFzZS1kcmFmdC1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxxRUFBcUU7QUFlMUM7QUFDc0Q7QUFDekM7QUFtQmpDLE1BQU1nQjtJQUlYOztHQUVDLEdBQ0QsYUFBYUMsaUJBQW1DO1FBQzlDLElBQUk7WUFDRiw4QkFBOEI7WUFDOUIsNkJBQTZCO1lBQzdCLE1BQU1DLElBQUlYLHlEQUFLQSxDQUFDUCw4REFBVUEsQ0FBQ2MseUNBQUVBLEVBQUUsSUFBSSxDQUFDSyxlQUFlLEdBQUdYLHlEQUFLQSxDQUFDLFlBQVksTUFBTTtZQUM5RSxNQUFNSiwyREFBT0EsQ0FBQ2M7WUFDZCxzQ0FBc0M7WUFDdEMsT0FBTztRQUNULEVBQUUsT0FBT0UsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsc0NBQXNDQTtZQUNwRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBZUUsWUFBWUMsR0FBUSxFQUFPO1FBQ3hDLElBQUlBLFFBQVEsUUFBUUEsUUFBUUMsV0FBVztZQUNyQyxPQUFPO1FBQ1Q7UUFFQSxJQUFJQyxNQUFNQyxPQUFPLENBQUNILE1BQU07WUFDdEIsT0FBT0EsSUFBSUksR0FBRyxDQUFDQyxDQUFBQSxPQUFRLElBQUksQ0FBQ04sV0FBVyxDQUFDTTtRQUMxQztRQUVBLElBQUksT0FBT0wsUUFBUSxZQUFZQSxJQUFJTSxXQUFXLEtBQUtDLFFBQVE7WUFDekQsTUFBTUMsVUFBZSxDQUFDO1lBQ3RCLElBQUssTUFBTUMsT0FBT1QsSUFBSztnQkFDckIsSUFBSUEsSUFBSVUsY0FBYyxDQUFDRCxNQUFNO29CQUMzQixNQUFNRSxRQUFRWCxHQUFHLENBQUNTLElBQUk7b0JBQ3RCLElBQUlFLFVBQVVWLFdBQVc7d0JBQ3ZCTyxPQUFPLENBQUNDLElBQUksR0FBRyxJQUFJLENBQUNWLFdBQVcsQ0FBQ1k7b0JBQ2xDO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPSDtRQUNUO1FBRUEsT0FBT1I7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RUFBRW1ELE1BQU07Z0JBQ3pEVSxrQkFBa0J0QyxPQUFPbUMsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFMUQsaUJBQWlCLElBQUkwRCxFQUFFMUQsaUJBQWlCLENBQUNrRCxNQUFNLEdBQUcsR0FBR0EsTUFBTTtZQUNwRztZQUVBLE9BQU9JO1FBQ1QsRUFBRSxPQUFPdkYsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxPQUFPO2dCQUNMd0YsYUFBYTtnQkFDYkMsZ0JBQWdCO2dCQUNoQkcsa0JBQWtCO2dCQUNsQkMsa0JBQWtCO1lBQ3BCO1FBQ0Y7SUFDRjtBQUNGO0FBL1dhakcscUJBQ2FHLGtCQUFrQjtBQUQvQkgscUJBRWEyRSxlQUFlIiwic291cmNlcyI6WyJEOlxcSXN0aWFuIEZpbGVzXFxUaXNlZ1xcQ1JZIEFwcFxcbGliXFxmaXJlYmFzZS1kcmFmdC1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpcmViYXNlIERyYWZ0IFNlcnZpY2UgLSBSZWFsLXRpbWUgZHJhZnQgbWFuYWdlbWVudCB3aXRoIEZpcmVzdG9yZVxyXG5pbXBvcnQgeyBcclxuICBjb2xsZWN0aW9uLCBcclxuICBkb2MsIFxyXG4gIGFkZERvYywgXHJcbiAgdXBkYXRlRG9jLCBcclxuICBkZWxldGVEb2MsIFxyXG4gIGdldERvY3MsIFxyXG4gIGdldERvYyxcclxuICBvblNuYXBzaG90LFxyXG4gIHF1ZXJ5LFxyXG4gIHdoZXJlLFxyXG4gIG9yZGVyQnksXHJcbiAgVGltZXN0YW1wLFxyXG4gIHNlcnZlclRpbWVzdGFtcFxyXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSdcclxuaW1wb3J0IHsgcmVmLCB1cGxvYWRCeXRlcywgZ2V0RG93bmxvYWRVUkwsIGRlbGV0ZU9iamVjdCB9IGZyb20gJ2ZpcmViYXNlL3N0b3JhZ2UnXHJcbmltcG9ydCB7IGRiLCBzdG9yYWdlIH0gZnJvbSAnLi9maXJlYmFzZSdcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VEcmFmdERhdGEge1xyXG4gIGlkPzogc3RyaW5nXHJcbiAgZHJhZnRJZDogc3RyaW5nXHJcbiAgY3JlYXRpdmVGaWxlbmFtZTogc3RyaW5nXHJcbiAgbGFzdFNhdmVkOiBUaW1lc3RhbXBcclxuICBjcmVhdGVkQXQ6IFRpbWVzdGFtcFxyXG4gIGF1dG9TYXZlZD86IGJvb2xlYW5cclxuICBmb3JtRGF0YTogYW55XHJcbiAgaW1hZ2VVcmw/OiBzdHJpbmdcclxuICBpbWFnZVN0b3JhZ2VQYXRoPzogc3RyaW5nXHJcbiAgdXNlcklkPzogc3RyaW5nXHJcbiAgLy8gQWRkaXRpb25hbCB0cmFja2luZyBmaWVsZHMgYXMgcGVyIHJlcXVpcmVtZW50c1xyXG4gIGFpUG9wdWxhdGVkRmllbGRzPzogc3RyaW5nW11cclxuICB2ZXJzaW9uOiBudW1iZXJcclxuICBpc0FjdGl2ZTogYm9vbGVhblxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VEcmFmdFNlcnZpY2Uge1xyXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IENPTExFQ1RJT05fTkFNRSA9ICdkcmFmdHMnXHJcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU1RPUkFHRV9QQVRIID0gJ2RyYWZ0LWltYWdlcydcclxuXHJcbiAgLyoqXHJcbiAgICogVGVzdCBGaXJlYmFzZSBjb25uZWN0aW9uXHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVGVzdGluZyBGaXJlYmFzZSBjb25uZWN0aW9uXHJcbiAgICAgIC8vIFRyeSB0byByZWFkIGZyb20gRmlyZXN0b3JlXHJcbiAgICAgIGNvbnN0IHEgPSBxdWVyeShjb2xsZWN0aW9uKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSksIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpKVxyXG4gICAgICBhd2FpdCBnZXREb2NzKHEpXHJcbiAgICAgIC8vIEZpcmViYXNlIGNvbm5lY3Rpb24gdGVzdCBzdWNjZXNzZnVsXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmlyZWJhc2UgY29ubmVjdGlvbiB0ZXN0IGZhaWxlZDonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiBvYmplY3QgdG8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgKEZpcmViYXNlIGRvZXNuJ3QgYWNjZXB0IHVuZGVmaW5lZClcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBjbGVhbk9iamVjdChvYmo6IGFueSk6IGFueSB7XHJcbiAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgcmV0dXJuIG9iai5tYXAoaXRlbSA9PiB0aGlzLmNsZWFuT2JqZWN0KGl0ZW0pKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcclxuICAgICAgY29uc3QgY2xlYW5lZDogYW55ID0ge31cclxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldXHJcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjbGVhbmVkW2tleV0gPSB0aGlzLmNsZWFuT2JqZWN0KHZhbHVlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2xlYW5lZFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb2JqXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTYXZlIG9yIHVwZGF0ZSBhIGRyYWZ0IGluIEZpcmVzdG9yZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBzYXZlRHJhZnQoZGF0YTogUGFydGlhbDxGaXJlYmFzZURyYWZ0RGF0YT4sIGltYWdlRmlsZT86IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2F2aW5nIGRyYWZ0IHRvIEZpcmViYXNlXHJcbiAgICAgIFxyXG4gICAgICAvLyBDbGVhbiB0aGUgZm9ybURhdGEgdG8gcmVtb3ZlIG5vbi1zZXJpYWxpemFibGUgb2JqZWN0cyBsaWtlIEZpbGUgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgY29uc3QgY2xlYW5Gb3JtRGF0YSA9IHRoaXMuY2xlYW5PYmplY3QoeyAuLi5kYXRhLmZvcm1EYXRhIH0pXHJcbiAgICAgIGlmIChjbGVhbkZvcm1EYXRhICYmIGNsZWFuRm9ybURhdGEudXBsb2FkZWRJbWFnZSkge1xyXG4gICAgICAgIC8vIFN0b3JlIG9ubHkgZmlsZSBtZXRhZGF0YSwgbm90IHRoZSBhY3R1YWwgRmlsZSBvYmplY3RcclxuICAgICAgICBjb25zdCBmaWxlID0gY2xlYW5Gb3JtRGF0YS51cGxvYWRlZEltYWdlIGFzIEZpbGVcclxuICAgICAgICBpZiAoZmlsZSAmJiB0eXBlb2YgZmlsZSA9PT0gJ29iamVjdCcgJiYgZmlsZS5uYW1lKSB7XHJcbiAgICAgICAgICBjbGVhbkZvcm1EYXRhLnVwbG9hZGVkSW1hZ2UgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGZpbGUubmFtZSxcclxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxyXG4gICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXHJcbiAgICAgICAgICAgIGxhc3RNb2RpZmllZDogZmlsZS5sYXN0TW9kaWZpZWQsXHJcbiAgICAgICAgICAgIGlzRmlsZU9iamVjdDogdHJ1ZSAvLyBGbGFnIHRvIGlkZW50aWZ5IHRoaXMgd2FzIGEgZmlsZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ2xlYW4gdGhlIGVudGlyZSBkcmFmdCBkYXRhIG9iamVjdCB0byByZW1vdmUgdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICBjb25zdCBkcmFmdERhdGEgPSB0aGlzLmNsZWFuT2JqZWN0KHtcclxuICAgICAgICBkcmFmdElkOiBkYXRhLmRyYWZ0SWQgfHwgdGhpcy5nZW5lcmF0ZURyYWZ0SWQoKSxcclxuICAgICAgICBjcmVhdGl2ZUZpbGVuYW1lOiBkYXRhLmNyZWF0aXZlRmlsZW5hbWUgfHwgJ1VudGl0bGVkJyxcclxuICAgICAgICBsYXN0U2F2ZWQ6IHNlcnZlclRpbWVzdGFtcCgpIGFzIFRpbWVzdGFtcCxcclxuICAgICAgICBhdXRvU2F2ZWQ6IGRhdGEuYXV0b1NhdmVkIHx8IGZhbHNlLFxyXG4gICAgICAgIGZvcm1EYXRhOiBjbGVhbkZvcm1EYXRhIHx8IHt9LFxyXG4gICAgICAgIGFpUG9wdWxhdGVkRmllbGRzOiBkYXRhLmFpUG9wdWxhdGVkRmllbGRzIHx8IFtdLFxyXG4gICAgICAgIHZlcnNpb246IChkYXRhLnZlcnNpb24gfHwgMCkgKyAxLFxyXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgIHVzZXJJZDogZGF0YS51c2VySWQgfHwgJ2Fub255bW91cycgLy8gSW4gcHJvZHVjdGlvbiwgdXNlIGFjdHVhbCB1c2VyIElEXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICAvLyBQcmVwYXJlZCBkcmFmdCBkYXRhIGZvciBGaXJlYmFzZVxyXG5cclxuICAgICAgLy8gSGFuZGxlIGltYWdlIHVwbG9hZCBpZiBwcm92aWRlZCAoc2tpcCBpZiBzdG9yYWdlIHBlcm1pc3Npb24gaXNzdWVzKVxyXG4gICAgICBpZiAoaW1hZ2VGaWxlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGF3YWl0IHRoaXMudXBsb2FkSW1hZ2UoaW1hZ2VGaWxlLCBkcmFmdERhdGEuZHJhZnRJZCEpXHJcbiAgICAgICAgICBkcmFmdERhdGEuaW1hZ2VVcmwgPSBpbWFnZURhdGEuZG93bmxvYWRVcmxcclxuICAgICAgICAgIGRyYWZ0RGF0YS5pbWFnZVN0b3JhZ2VQYXRoID0gaW1hZ2VEYXRhLnN0b3JhZ2VQYXRoXHJcbiAgICAgICAgICAvLyBJbWFnZSB1cGxvYWRlZCBzdWNjZXNzZnVsbHlcclxuICAgICAgICB9IGNhdGNoIChpbWFnZUVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBJbWFnZSB1cGxvYWQgZmFpbGVkLCBjb250aW51aW5nIHdpdGhvdXQgaW1hZ2U6JywgaW1hZ2VFcnJvcilcclxuICAgICAgICAgIC8vIERvbid0IGZhaWwgdGhlIGVudGlyZSBkcmFmdCBzYXZlIGlmIGltYWdlIHVwbG9hZCBmYWlsc1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgZHJhZnRJZCBleGlzdHMsIHVwZGF0ZSBleGlzdGluZyBkb2N1bWVudFxyXG4gICAgICBpZiAoZGF0YS5pZCkge1xyXG4gICAgICAgIC8vIFVwZGF0aW5nIGV4aXN0aW5nIGRyYWZ0XHJcbiAgICAgICAgY29uc3QgZHJhZnRSZWYgPSBkb2MoZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FLCBkYXRhLmlkKVxyXG4gICAgICAgIGF3YWl0IHVwZGF0ZURvYyhkcmFmdFJlZiwge1xyXG4gICAgICAgICAgLi4uZHJhZnREYXRhLFxyXG4gICAgICAgICAgbGFzdFNhdmVkOiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy8gRHJhZnQgdXBkYXRlZCBzdWNjZXNzZnVsbHlcclxuICAgICAgICByZXR1cm4gZGF0YS5pZFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgZHJhZnRcclxuICAgICAgICAvLyBDcmVhdGluZyBuZXcgZHJhZnQgZG9jdW1lbnRcclxuICAgICAgICBkcmFmdERhdGEuY3JlYXRlZEF0ID0gc2VydmVyVGltZXN0YW1wKCkgYXMgVGltZXN0YW1wXHJcbiAgICAgICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FKSwgZHJhZnREYXRhKVxyXG4gICAgICAgIC8vIE5ldyBkcmFmdCBjcmVhdGVkXHJcbiAgICAgICAgcmV0dXJuIGRvY1JlZi5pZFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmFpbGVkIHRvIHNhdmUgZHJhZnQgdG8gRmlyZWJhc2U6JywgZXJyb3IpXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZpcmViYXNlIGVycm9yIGRldGFpbHM6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNhdmUgZHJhZnQ6ICR7ZXJyb3J9YClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIHNpbmdsZSBkcmFmdCBieSBJRFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBnZXREcmFmdChpZDogc3RyaW5nKTogUHJvbWlzZTxGaXJlYmFzZURyYWZ0RGF0YSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRyYWZ0UmVmID0gZG9jKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSwgaWQpXHJcbiAgICAgIGNvbnN0IGRyYWZ0U25hcCA9IGF3YWl0IGdldERvYyhkcmFmdFJlZilcclxuICAgICAgXHJcbiAgICAgIGlmIChkcmFmdFNuYXAuZXhpc3RzKCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgaWQ6IGRyYWZ0U25hcC5pZCxcclxuICAgICAgICAgIC4uLmRyYWZ0U25hcC5kYXRhKClcclxuICAgICAgICB9IGFzIEZpcmViYXNlRHJhZnREYXRhXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZHJhZnQ6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIGFjdGl2ZSBkcmFmdHMgZm9yIGEgdXNlclxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBnZXRBbGxEcmFmdHModXNlcklkOiBzdHJpbmcgPSAnYW5vbnltb3VzJyk6IFByb21pc2U8RmlyZWJhc2VEcmFmdERhdGFbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU2ltcGxpZmllZCBxdWVyeSB0byBhdm9pZCBuZWVkaW5nIGEgY29tcG9zaXRlIGluZGV4XHJcbiAgICAgIGNvbnN0IHEgPSBxdWVyeShcclxuICAgICAgICBjb2xsZWN0aW9uKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSksXHJcbiAgICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXHJcbiAgICAgICAgd2hlcmUoJ2lzQWN0aXZlJywgJz09JywgdHJ1ZSlcclxuICAgICAgKVxyXG4gICAgICBcclxuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSlcclxuICAgICAgY29uc3QgZHJhZnRzOiBGaXJlYmFzZURyYWZ0RGF0YVtdID0gW11cclxuICAgICAgXHJcbiAgICAgIHF1ZXJ5U25hcHNob3QuZm9yRWFjaCgoZG9jKSA9PiB7XHJcbiAgICAgICAgZHJhZnRzLnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGRvYy5pZCxcclxuICAgICAgICAgIC4uLmRvYy5kYXRhKClcclxuICAgICAgICB9IGFzIEZpcmViYXNlRHJhZnREYXRhKVxyXG4gICAgICB9KVxyXG4gICAgICBcclxuICAgICAgLy8gU29ydCBieSBsYXN0U2F2ZWQgaW4gbWVtb3J5IHRvIGF2b2lkIG5lZWRpbmcgYSBjb21wb3NpdGUgaW5kZXhcclxuICAgICAgcmV0dXJuIGRyYWZ0cy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYVRpbWUgPSBhLmxhc3RTYXZlZD8udG9EYXRlPy4oKT8uZ2V0VGltZSgpIHx8IDBcclxuICAgICAgICBjb25zdCBiVGltZSA9IGIubGFzdFNhdmVkPy50b0RhdGU/LigpPy5nZXRUaW1lKCkgfHwgMFxyXG4gICAgICAgIHJldHVybiBiVGltZSAtIGFUaW1lIC8vIERlc2Mgb3JkZXJcclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgZHJhZnRzOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gW11cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBhIGRyYWZ0IChzb2Z0IGRlbGV0ZSBieSBtYXJraW5nIGFzIGluYWN0aXZlKVxyXG4gICAqL1xyXG4gIHN0YXRpYyBhc3luYyBkZWxldGVEcmFmdChpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkcmFmdFJlZiA9IGRvYyhkYiwgdGhpcy5DT0xMRUNUSU9OX05BTUUsIGlkKVxyXG4gICAgICBcclxuICAgICAgLy8gR2V0IGRyYWZ0IGRhdGEgdG8gY2xlYW4gdXAgaW1hZ2UgaWYgbmVlZGVkXHJcbiAgICAgIGNvbnN0IGRyYWZ0U25hcCA9IGF3YWl0IGdldERvYyhkcmFmdFJlZilcclxuICAgICAgaWYgKGRyYWZ0U25hcC5leGlzdHMoKSkge1xyXG4gICAgICAgIGNvbnN0IGRyYWZ0RGF0YSA9IGRyYWZ0U25hcC5kYXRhKCkgYXMgRmlyZWJhc2VEcmFmdERhdGFcclxuICAgICAgICBcclxuICAgICAgICAvLyBEZWxldGUgaW1hZ2UgZnJvbSBzdG9yYWdlIGlmIGV4aXN0c1xyXG4gICAgICAgIGlmIChkcmFmdERhdGEuaW1hZ2VTdG9yYWdlUGF0aCkge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVJbWFnZShkcmFmdERhdGEuaW1hZ2VTdG9yYWdlUGF0aClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFNvZnQgZGVsZXRlIGJ5IG1hcmtpbmcgYXMgaW5hY3RpdmVcclxuICAgICAgYXdhaXQgdXBkYXRlRG9jKGRyYWZ0UmVmLCB7XHJcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxyXG4gICAgICAgIGxhc3RTYXZlZDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgfSlcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGRyYWZ0OicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB1cCByZWFsLXRpbWUgbGlzdGVuZXIgZm9yIGRyYWZ0c1xyXG4gICAqL1xyXG4gIHN0YXRpYyBvbkRyYWZ0c0NoYW5nZSh1c2VySWQ6IHN0cmluZyA9ICdhbm9ueW1vdXMnLCBjYWxsYmFjazogKGRyYWZ0czogRmlyZWJhc2VEcmFmdERhdGFbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xyXG4gICAgLy8gU2ltcGxpZmllZCBxdWVyeSB0byBhdm9pZCBuZWVkaW5nIGEgY29tcG9zaXRlIGluZGV4XHJcbiAgICBjb25zdCBxID0gcXVlcnkoXHJcbiAgICAgIGNvbGxlY3Rpb24oZGIsIHRoaXMuQ09MTEVDVElPTl9OQU1FKSxcclxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXHJcbiAgICAgIHdoZXJlKCdpc0FjdGl2ZScsICc9PScsIHRydWUpXHJcbiAgICApXHJcblxyXG4gICAgcmV0dXJuIG9uU25hcHNob3QocSwgKHF1ZXJ5U25hcHNob3QpID0+IHtcclxuICAgICAgY29uc3QgZHJhZnRzOiBGaXJlYmFzZURyYWZ0RGF0YVtdID0gW11cclxuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcclxuICAgICAgICBkcmFmdHMucHVzaCh7XHJcbiAgICAgICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAgICAgLi4uZG9jLmRhdGEoKVxyXG4gICAgICAgIH0gYXMgRmlyZWJhc2VEcmFmdERhdGEpXHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICAvLyBTb3J0IGJ5IGxhc3RTYXZlZCBpbiBtZW1vcnkgdG8gYXZvaWQgbmVlZGluZyBhIGNvbXBvc2l0ZSBpbmRleFxyXG4gICAgICBjb25zdCBzb3J0ZWREcmFmdHMgPSBkcmFmdHMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFUaW1lID0gYS5sYXN0U2F2ZWQ/LnRvRGF0ZT8uKCk/LmdldFRpbWUoKSB8fCAwXHJcbiAgICAgICAgY29uc3QgYlRpbWUgPSBiLmxhc3RTYXZlZD8udG9EYXRlPy4oKT8uZ2V0VGltZSgpIHx8IDBcclxuICAgICAgICByZXR1cm4gYlRpbWUgLSBhVGltZSAvLyBEZXNjIG9yZGVyXHJcbiAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICBjYWxsYmFjayhzb3J0ZWREcmFmdHMpXHJcbiAgICB9LCAoZXJyb3IpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcignUmVhbC10aW1lIGRyYWZ0cyBsaXN0ZW5lciBlcnJvcjonLCBlcnJvcilcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdXAgcmVhbC10aW1lIGxpc3RlbmVyIGZvciBhIHNwZWNpZmljIGRyYWZ0XHJcbiAgICovXHJcbiAgc3RhdGljIG9uRHJhZnRDaGFuZ2UoZHJhZnRJZDogc3RyaW5nLCBjYWxsYmFjazogKGRyYWZ0OiBGaXJlYmFzZURyYWZ0RGF0YSB8IG51bGwpID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcclxuICAgIGNvbnN0IGRyYWZ0UmVmID0gZG9jKGRiLCB0aGlzLkNPTExFQ1RJT05fTkFNRSwgZHJhZnRJZClcclxuICAgIFxyXG4gICAgcmV0dXJuIG9uU25hcHNob3QoZHJhZnRSZWYsIChkb2MpID0+IHtcclxuICAgICAgaWYgKGRvYy5leGlzdHMoKSkge1xyXG4gICAgICAgIGNhbGxiYWNrKHtcclxuICAgICAgICAgIGlkOiBkb2MuaWQsXHJcbiAgICAgICAgICAuLi5kb2MuZGF0YSgpXHJcbiAgICAgICAgfSBhcyBGaXJlYmFzZURyYWZ0RGF0YSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjYWxsYmFjayhudWxsKVxyXG4gICAgICB9XHJcbiAgICB9LCAoZXJyb3IpID0+IHtcclxuICAgICAgY29uc29sZS5lcnJvcignUmVhbC10aW1lIGRyYWZ0IGxpc3RlbmVyIGVycm9yOicsIGVycm9yKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwbG9hZCBpbWFnZSB0byBGaXJlYmFzZSBTdG9yYWdlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgdXBsb2FkSW1hZ2UoZmlsZTogRmlsZSwgZHJhZnRJZDogc3RyaW5nKTogUHJvbWlzZTx7IGRvd25sb2FkVXJsOiBzdHJpbmcsIHN0b3JhZ2VQYXRoOiBzdHJpbmcgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmFnZVBhdGggPSBgJHt0aGlzLlNUT1JBR0VfUEFUSH0vJHtkcmFmdElkfS8ke2ZpbGUubmFtZX1gXHJcbiAgICAgIGNvbnN0IGltYWdlUmVmID0gcmVmKHN0b3JhZ2UsIHN0b3JhZ2VQYXRoKVxyXG4gICAgICBcclxuICAgICAgYXdhaXQgdXBsb2FkQnl0ZXMoaW1hZ2VSZWYsIGZpbGUpXHJcbiAgICAgIGNvbnN0IGRvd25sb2FkVXJsID0gYXdhaXQgZ2V0RG93bmxvYWRVUkwoaW1hZ2VSZWYpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4geyBkb3dubG9hZFVybCwgc3RvcmFnZVBhdGggfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwbG9hZCBpbWFnZTonLCBlcnJvcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGltYWdlJylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlbGV0ZSBpbWFnZSBmcm9tIEZpcmViYXNlIFN0b3JhZ2VcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBhc3luYyBkZWxldGVJbWFnZShzdG9yYWdlUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBpbWFnZVJlZiA9IHJlZihzdG9yYWdlLCBzdG9yYWdlUGF0aClcclxuICAgICAgYXdhaXQgZGVsZXRlT2JqZWN0KGltYWdlUmVmKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBpbWFnZTonLCBlcnJvcilcclxuICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgYXMgdGhpcyBpcyBjbGVhbnVwXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSB1bmlxdWUgZHJhZnQgSURcclxuICAgKi9cclxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZURyYWZ0SWQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBgZHJhZnRfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaWdyYXRlIGV4aXN0aW5nIGxvY2FsU3RvcmFnZSBkcmFmdHMgdG8gRmlyZWJhc2VcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgbWlncmF0ZUxvY2FsRHJhZnRzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gSW1wb3J0IHRoZSBleGlzdGluZyBkcmFmdCBzdG9yYWdlIHRvIGFjY2VzcyBsb2NhbCBkcmFmdHNcclxuICAgICAgY29uc3QgeyBEcmFmdFN0b3JhZ2VWMiB9ID0gYXdhaXQgaW1wb3J0KCcuLi91dGlscy9kcmFmdFN0b3JhZ2UudjInKVxyXG4gICAgICBjb25zdCBsb2NhbERyYWZ0cyA9IERyYWZ0U3RvcmFnZVYyLmdldEFsbERyYWZ0cygpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtsb2NhbERyYWZ0cy5sZW5ndGh9IGxvY2FsIGRyYWZ0cyB0byBtaWdyYXRlYClcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgbG9jYWxEcmFmdCBvZiBsb2NhbERyYWZ0cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBmaXJlYmFzZURyYWZ0OiBQYXJ0aWFsPEZpcmViYXNlRHJhZnREYXRhPiA9IHtcclxuICAgICAgICAgICAgZHJhZnRJZDogbG9jYWxEcmFmdC5kcmFmdElkLFxyXG4gICAgICAgICAgICBjcmVhdGl2ZUZpbGVuYW1lOiBsb2NhbERyYWZ0LmNyZWF0aXZlRmlsZW5hbWUsXHJcbiAgICAgICAgICAgIGZvcm1EYXRhOiBsb2NhbERyYWZ0LmZvcm1EYXRhLFxyXG4gICAgICAgICAgICBhdXRvU2F2ZWQ6IGxvY2FsRHJhZnQuYXV0b1NhdmVkLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxyXG4gICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVEcmFmdChmaXJlYmFzZURyYWZ0KVxyXG4gICAgICAgICAgY29uc29sZS5sb2coYE1pZ3JhdGVkIGRyYWZ0OiAke2xvY2FsRHJhZnQuY3JlYXRpdmVGaWxlbmFtZX1gKVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbWlncmF0ZSBkcmFmdCAke2xvY2FsRHJhZnQuZHJhZnRJZH06YCwgZXJyb3IpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnRHJhZnQgbWlncmF0aW9uIGNvbXBsZXRlZCcpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbWlncmF0ZSBsb2NhbCBkcmFmdHM6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgcmVhbC10aW1lIHRyYWNraW5nIHN0YXRpc3RpY3NcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgZ2V0VHJhY2tpbmdTdGF0cyh1c2VySWQ6IHN0cmluZyA9ICdhbm9ueW1vdXMnKTogUHJvbWlzZTx7XHJcbiAgICB0b3RhbERyYWZ0czogbnVtYmVyXHJcbiAgICBhdXRvU2F2ZWRDb3VudDogbnVtYmVyXHJcbiAgICBtYW51YWxTYXZlZENvdW50OiBudW1iZXJcclxuICAgIGFpUG9wdWxhdGVkQ291bnQ6IG51bWJlclxyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRyYWZ0cyA9IGF3YWl0IHRoaXMuZ2V0QWxsRHJhZnRzKHVzZXJJZClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHN0YXRzID0ge1xyXG4gICAgICAgIHRvdGFsRHJhZnRzOiBkcmFmdHMubGVuZ3RoLFxyXG4gICAgICAgIGF1dG9TYXZlZENvdW50OiBkcmFmdHMuZmlsdGVyKGQgPT4gZC5hdXRvU2F2ZWQpLmxlbmd0aCxcclxuICAgICAgICBtYW51YWxTYXZlZENvdW50OiBkcmFmdHMuZmlsdGVyKGQgPT4gIWQuYXV0b1NhdmVkKS5sZW5ndGgsXHJcbiAgICAgICAgYWlQb3B1bGF0ZWRDb3VudDogZHJhZnRzLmZpbHRlcihkID0+IGQuYWlQb3B1bGF0ZWRGaWVsZHMgJiYgZC5haVBvcHVsYXRlZEZpZWxkcy5sZW5ndGggPiAwKS5sZW5ndGhcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHN0YXRzXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IHRyYWNraW5nIHN0YXRzOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvdGFsRHJhZnRzOiAwLFxyXG4gICAgICAgIGF1dG9TYXZlZENvdW50OiAwLFxyXG4gICAgICAgIG1hbnVhbFNhdmVkQ291bnQ6IDAsXHJcbiAgICAgICAgYWlQb3B1bGF0ZWRDb3VudDogMFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbImNvbGxlY3Rpb24iLCJkb2MiLCJhZGREb2MiLCJ1cGRhdGVEb2MiLCJnZXREb2NzIiwiZ2V0RG9jIiwib25TbmFwc2hvdCIsInF1ZXJ5Iiwid2hlcmUiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJyZWYiLCJ1cGxvYWRCeXRlcyIsImdldERvd25sb2FkVVJMIiwiZGVsZXRlT2JqZWN0IiwiZGIiLCJzdG9yYWdlIiwiRmlyZWJhc2VEcmFmdFNlcnZpY2UiLCJ0ZXN0Q29ubmVjdGlvbiIsInEiLCJDT0xMRUNUSU9OX05BTUUiLCJlcnJvciIsImNvbnNvbGUiLCJjbGVhbk9iamVjdCIsIm9iaiIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIml0ZW0iLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImNsZWFuZWQiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInZhbHVlIiwic2F2ZURyYWZ0IiwiZGF0YSIsImltYWdlRmlsZSIsImNsZWFuRm9ybURhdGEiLCJmb3JtRGF0YSIsInVwbG9hZGVkSW1hZ2UiLCJmaWxlIiwibmFtZSIsInNpemUiLCJ0eXBlIiwibGFzdE1vZGlmaWVkIiwiaXNGaWxlT2JqZWN0IiwiZHJhZnREYXRhIiwiZHJhZnRJZCIsImdlbmVyYXRlRHJhZnRJZCIsImNyZWF0aXZlRmlsZW5hbWUiLCJsYXN0U2F2ZWQiLCJhdXRvU2F2ZWQiLCJhaVBvcHVsYXRlZEZpZWxkcyIsInZlcnNpb24iLCJpc0FjdGl2ZSIsInVzZXJJZCIsImltYWdlRGF0YSIsInVwbG9hZEltYWdlIiwiaW1hZ2VVcmwiLCJkb3dubG9hZFVybCIsImltYWdlU3RvcmFnZVBhdGgiLCJzdG9yYWdlUGF0aCIsImltYWdlRXJyb3IiLCJ3YXJuIiwiaWQiLCJkcmFmdFJlZiIsImNyZWF0ZWRBdCIsImRvY1JlZiIsIkVycm9yIiwiZ2V0RHJhZnQiLCJkcmFmdFNuYXAiLCJleGlzdHMiLCJnZXRBbGxEcmFmdHMiLCJxdWVyeVNuYXBzaG90IiwiZHJhZnRzIiwiZm9yRWFjaCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJhVGltZSIsInRvRGF0ZSIsImdldFRpbWUiLCJiVGltZSIsImRlbGV0ZURyYWZ0IiwiZGVsZXRlSW1hZ2UiLCJvbkRyYWZ0c0NoYW5nZSIsImNhbGxiYWNrIiwic29ydGVkRHJhZnRzIiwib25EcmFmdENoYW5nZSIsIlNUT1JBR0VfUEFUSCIsImltYWdlUmVmIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsIm1pZ3JhdGVMb2NhbERyYWZ0cyIsIkRyYWZ0U3RvcmFnZVYyIiwibG9jYWxEcmFmdHMiLCJsb2ciLCJsZW5ndGgiLCJsb2NhbERyYWZ0IiwiZmlyZWJhc2VEcmFmdCIsImdldFRyYWNraW5nU3RhdHMiLCJzdGF0cyIsInRvdGFsRHJhZnRzIiwiYXV0b1NhdmVkQ291bnQiLCJmaWx0ZXIiLCJkIiwibWFudWFsU2F2ZWRDb3VudCIsImFpUG9wdWxhdGVkQ291bnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/firebase-draft-service.ts\n"));

/***/ })

});