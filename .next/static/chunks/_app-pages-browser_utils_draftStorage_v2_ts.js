"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_utils_draftStorage_v2_ts"],{

/***/ "(app-pages-browser)/./utils/draftStorage.v2.ts":
/*!**********************************!*\
  !*** ./utils/draftStorage.v2.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DraftStorageV2: () => (/* binding */ DraftStorageV2)\n/* harmony export */ });\nclass DraftStorageV2 {\n    static saveDraft(data) {\n        const draftId = data.draftId || this.generateDraftId();\n        const draftData = {\n            draftId,\n            creativeFilename: data.creativeFilename || 'Untitled',\n            lastSaved: new Date().toISOString(),\n            autoSaved: data.autoSaved || false,\n            formData: data.formData || {},\n            imageUrl: data.imageUrl\n        };\n        const key = \"\".concat(this.V2_PREFIX).concat(draftId);\n        localStorage.setItem(key, JSON.stringify(draftData));\n        return draftId;\n    }\n    static getDraft(draftId) {\n        const key = \"\".concat(this.V2_PREFIX).concat(draftId);\n        const data = localStorage.getItem(key);\n        if (data) {\n            return JSON.parse(data);\n        }\n        // Check for legacy format\n        const legacyData = this.getLegacyDraft(draftId);\n        if (legacyData) {\n            return legacyData;\n        }\n        return null;\n    }\n    static getAllDrafts() {\n        const drafts = [];\n        // Get V2 drafts\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key === null || key === void 0 ? void 0 : key.startsWith(this.V2_PREFIX)) {\n                const data = localStorage.getItem(key);\n                if (data) {\n                    try {\n                        drafts.push(JSON.parse(data));\n                    } catch (e) {\n                        console.error('Failed to parse draft:', key, e);\n                    }\n                }\n            }\n        }\n        // Get legacy drafts\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if ((key === null || key === void 0 ? void 0 : key.startsWith(this.DRAFT_PREFIX)) && !key.startsWith(this.V2_PREFIX)) {\n                const legacyDraft = this.getLegacyDraftByKey(key);\n                if (legacyDraft && !drafts.some((d)=>d.creativeFilename === legacyDraft.creativeFilename)) {\n                    drafts.push(legacyDraft);\n                }\n            }\n        }\n        return drafts;\n    }\n    static deleteDraft(draftId) {\n        // Try V2 format first\n        const v2Key = \"\".concat(this.V2_PREFIX).concat(draftId);\n        if (localStorage.getItem(v2Key)) {\n            localStorage.removeItem(v2Key);\n            return true;\n        }\n        // Try legacy format\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key === null || key === void 0 ? void 0 : key.startsWith(this.DRAFT_PREFIX)) {\n                const data = localStorage.getItem(key);\n                if (data) {\n                    try {\n                        const parsed = JSON.parse(data);\n                        if (parsed.creativeFilename === draftId || key === \"\".concat(this.DRAFT_PREFIX).concat(draftId)) {\n                            localStorage.removeItem(key);\n                            return true;\n                        }\n                    } catch (e) {\n                        // Try direct match\n                        if (key === \"\".concat(this.DRAFT_PREFIX).concat(draftId)) {\n                            localStorage.removeItem(key);\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    static migrateFromV1() {\n        const migrated = [];\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if ((key === null || key === void 0 ? void 0 : key.startsWith(this.DRAFT_PREFIX)) && !key.startsWith(this.V2_PREFIX)) {\n                const data = localStorage.getItem(key);\n                if (data) {\n                    try {\n                        const parsed = JSON.parse(data);\n                        const filename = key.replace(this.DRAFT_PREFIX, '');\n                        // Create V2 draft\n                        const v2Draft = {\n                            draftId: this.generateDraftId(),\n                            creativeFilename: parsed.creativeFilename || filename,\n                            lastSaved: parsed.savedAt || new Date().toISOString(),\n                            autoSaved: parsed.autoSaved || false,\n                            formData: parsed,\n                            imageUrl: undefined // Legacy format didn't store image URLs\n                        };\n                        // Save as V2\n                        const v2Key = \"\".concat(this.V2_PREFIX).concat(v2Draft.draftId);\n                        localStorage.setItem(v2Key, JSON.stringify(v2Draft));\n                        migrated.push(key);\n                    } catch (e) {\n                        console.error('Failed to migrate draft:', key, e);\n                    }\n                }\n            }\n        }\n        // Remove migrated legacy drafts\n        migrated.forEach((key)=>{\n            localStorage.removeItem(key);\n        });\n        if (migrated.length > 0) {\n            console.log(\"Migrated \".concat(migrated.length, \" drafts to V2 format\"));\n        }\n    }\n    static getLegacyDraft(filename) {\n        const key = \"\".concat(this.DRAFT_PREFIX).concat(filename);\n        const data = localStorage.getItem(key);\n        if (data) {\n            try {\n                const parsed = JSON.parse(data);\n                return {\n                    draftId: filename,\n                    creativeFilename: parsed.creativeFilename || filename,\n                    lastSaved: parsed.savedAt || new Date().toISOString(),\n                    autoSaved: parsed.autoSaved || false,\n                    formData: parsed,\n                    imageUrl: undefined\n                };\n            } catch (e) {\n                console.error('Failed to parse legacy draft:', key, e);\n            }\n        }\n        return null;\n    }\n    static getLegacyDraftByKey(key) {\n        const data = localStorage.getItem(key);\n        if (data) {\n            try {\n                const parsed = JSON.parse(data);\n                const filename = key.replace(this.DRAFT_PREFIX, '');\n                return {\n                    draftId: filename,\n                    creativeFilename: parsed.creativeFilename || filename,\n                    lastSaved: parsed.savedAt || new Date().toISOString(),\n                    autoSaved: parsed.autoSaved || false,\n                    formData: parsed,\n                    imageUrl: undefined\n                };\n            } catch (e) {\n                console.error('Failed to parse legacy draft:', key, e);\n            }\n        }\n        return null;\n    }\n    static generateDraftId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n}\nDraftStorageV2.DRAFT_PREFIX = 'single-upload-draft-';\nDraftStorageV2.V2_PREFIX = 'draft-v2-';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2RyYWZ0U3RvcmFnZS52Mi50cyIsIm1hcHBpbmdzIjoiOzs7O0FBU08sTUFBTUE7SUFJWCxPQUFPQyxVQUFVQyxJQUEwQixFQUFVO1FBQ25ELE1BQU1DLFVBQVVELEtBQUtDLE9BQU8sSUFBSSxJQUFJLENBQUNDLGVBQWU7UUFDcEQsTUFBTUMsWUFBeUI7WUFDN0JGO1lBQ0FHLGtCQUFrQkosS0FBS0ksZ0JBQWdCLElBQUk7WUFDM0NDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUNqQ0MsV0FBV1IsS0FBS1EsU0FBUyxJQUFJO1lBQzdCQyxVQUFVVCxLQUFLUyxRQUFRLElBQUksQ0FBQztZQUM1QkMsVUFBVVYsS0FBS1UsUUFBUTtRQUN6QjtRQUVBLE1BQU1DLE1BQU0sR0FBb0JWLE9BQWpCLElBQUksQ0FBQ1csU0FBUyxFQUFXLE9BQVJYO1FBQ2hDWSxhQUFhQyxPQUFPLENBQUNILEtBQUtJLEtBQUtDLFNBQVMsQ0FBQ2I7UUFDekMsT0FBT0Y7SUFDVDtJQUVBLE9BQU9nQixTQUFTaEIsT0FBZSxFQUFzQjtRQUNuRCxNQUFNVSxNQUFNLEdBQW9CVixPQUFqQixJQUFJLENBQUNXLFNBQVMsRUFBVyxPQUFSWDtRQUNoQyxNQUFNRCxPQUFPYSxhQUFhSyxPQUFPLENBQUNQO1FBQ2xDLElBQUlYLE1BQU07WUFDUixPQUFPZSxLQUFLSSxLQUFLLENBQUNuQjtRQUNwQjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNb0IsYUFBYSxJQUFJLENBQUNDLGNBQWMsQ0FBQ3BCO1FBQ3ZDLElBQUltQixZQUFZO1lBQ2QsT0FBT0E7UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBLE9BQU9FLGVBQThCO1FBQ25DLE1BQU1DLFNBQXdCLEVBQUU7UUFFaEMsZ0JBQWdCO1FBQ2hCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJWCxhQUFhWSxNQUFNLEVBQUVELElBQUs7WUFDNUMsTUFBTWIsTUFBTUUsYUFBYUYsR0FBRyxDQUFDYTtZQUM3QixJ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L2QvSXN0aWFuIEZpbGVzL1Rpc2VnL0NSWSBBcHAvdXRpbHMvZHJhZnRTdG9yYWdlLnYyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgRHJhZnREYXRhVjIge1xyXG4gIGRyYWZ0SWQ6IHN0cmluZ1xyXG4gIGNyZWF0aXZlRmlsZW5hbWU6IHN0cmluZ1xyXG4gIGxhc3RTYXZlZDogc3RyaW5nXHJcbiAgYXV0b1NhdmVkPzogYm9vbGVhblxyXG4gIGZvcm1EYXRhOiBhbnlcclxuICBpbWFnZVVybD86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRHJhZnRTdG9yYWdlVjIge1xyXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERSQUZUX1BSRUZJWCA9ICdzaW5nbGUtdXBsb2FkLWRyYWZ0LSdcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBWMl9QUkVGSVggPSAnZHJhZnQtdjItJ1xyXG4gIFxyXG4gIHN0YXRpYyBzYXZlRHJhZnQoZGF0YTogUGFydGlhbDxEcmFmdERhdGFWMj4pOiBzdHJpbmcge1xyXG4gICAgY29uc3QgZHJhZnRJZCA9IGRhdGEuZHJhZnRJZCB8fCB0aGlzLmdlbmVyYXRlRHJhZnRJZCgpXHJcbiAgICBjb25zdCBkcmFmdERhdGE6IERyYWZ0RGF0YVYyID0ge1xyXG4gICAgICBkcmFmdElkLFxyXG4gICAgICBjcmVhdGl2ZUZpbGVuYW1lOiBkYXRhLmNyZWF0aXZlRmlsZW5hbWUgfHwgJ1VudGl0bGVkJyxcclxuICAgICAgbGFzdFNhdmVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIGF1dG9TYXZlZDogZGF0YS5hdXRvU2F2ZWQgfHwgZmFsc2UsXHJcbiAgICAgIGZvcm1EYXRhOiBkYXRhLmZvcm1EYXRhIHx8IHt9LFxyXG4gICAgICBpbWFnZVVybDogZGF0YS5pbWFnZVVybFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBrZXkgPSBgJHt0aGlzLlYyX1BSRUZJWH0ke2RyYWZ0SWR9YFxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkcmFmdERhdGEpKVxyXG4gICAgcmV0dXJuIGRyYWZ0SWRcclxuICB9XHJcbiAgXHJcbiAgc3RhdGljIGdldERyYWZ0KGRyYWZ0SWQ6IHN0cmluZyk6IERyYWZ0RGF0YVYyIHwgbnVsbCB7XHJcbiAgICBjb25zdCBrZXkgPSBgJHt0aGlzLlYyX1BSRUZJWH0ke2RyYWZ0SWR9YFxyXG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSlcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGZvciBsZWdhY3kgZm9ybWF0XHJcbiAgICBjb25zdCBsZWdhY3lEYXRhID0gdGhpcy5nZXRMZWdhY3lEcmFmdChkcmFmdElkKVxyXG4gICAgaWYgKGxlZ2FjeURhdGEpIHtcclxuICAgICAgcmV0dXJuIGxlZ2FjeURhdGFcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcbiAgXHJcbiAgc3RhdGljIGdldEFsbERyYWZ0cygpOiBEcmFmdERhdGFWMltdIHtcclxuICAgIGNvbnN0IGRyYWZ0czogRHJhZnREYXRhVjJbXSA9IFtdXHJcbiAgICBcclxuICAgIC8vIEdldCBWMiBkcmFmdHNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSlcclxuICAgICAgaWYgKGtleT8uc3RhcnRzV2l0aCh0aGlzLlYyX1BSRUZJWCkpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkcmFmdHMucHVzaChKU09OLnBhcnNlKGRhdGEpKVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgZHJhZnQ6Jywga2V5LCBlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBHZXQgbGVnYWN5IGRyYWZ0c1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKVxyXG4gICAgICBpZiAoa2V5Py5zdGFydHNXaXRoKHRoaXMuRFJBRlRfUFJFRklYKSAmJiAha2V5LnN0YXJ0c1dpdGgodGhpcy5WMl9QUkVGSVgpKSB7XHJcbiAgICAgICAgY29uc3QgbGVnYWN5RHJhZnQgPSB0aGlzLmdldExlZ2FjeURyYWZ0QnlLZXkoa2V5KVxyXG4gICAgICAgIGlmIChsZWdhY3lEcmFmdCAmJiAhZHJhZnRzLnNvbWUoZCA9PiBkLmNyZWF0aXZlRmlsZW5hbWUgPT09IGxlZ2FjeURyYWZ0LmNyZWF0aXZlRmlsZW5hbWUpKSB7XHJcbiAgICAgICAgICBkcmFmdHMucHVzaChsZWdhY3lEcmFmdClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGRyYWZ0c1xyXG4gIH1cclxuICBcclxuICBzdGF0aWMgZGVsZXRlRHJhZnQoZHJhZnRJZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAvLyBUcnkgVjIgZm9ybWF0IGZpcnN0XHJcbiAgICBjb25zdCB2MktleSA9IGAke3RoaXMuVjJfUFJFRklYfSR7ZHJhZnRJZH1gXHJcbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0odjJLZXkpKSB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHYyS2V5KVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUcnkgbGVnYWN5IGZvcm1hdFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKVxyXG4gICAgICBpZiAoa2V5Py5zdGFydHNXaXRoKHRoaXMuRFJBRlRfUFJFRklYKSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSlcclxuICAgICAgICAgICAgaWYgKHBhcnNlZC5jcmVhdGl2ZUZpbGVuYW1lID09PSBkcmFmdElkIHx8IGtleSA9PT0gYCR7dGhpcy5EUkFGVF9QUkVGSVh9JHtkcmFmdElkfWApIHtcclxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBUcnkgZGlyZWN0IG1hdGNoXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGAke3RoaXMuRFJBRlRfUFJFRklYfSR7ZHJhZnRJZH1gKSB7XHJcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxyXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIFxyXG4gIHN0YXRpYyBtaWdyYXRlRnJvbVYxKCk6IHZvaWQge1xyXG4gICAgY29uc3QgbWlncmF0ZWQ6IHN0cmluZ1tdID0gW11cclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKVxyXG4gICAgICBpZiAoa2V5Py5zdGFydHNXaXRoKHRoaXMuRFJBRlRfUFJFRklYKSAmJiAha2V5LnN0YXJ0c1dpdGgodGhpcy5WMl9QUkVGSVgpKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSlcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKVxyXG4gICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGtleS5yZXBsYWNlKHRoaXMuRFJBRlRfUFJFRklYLCAnJylcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBWMiBkcmFmdFxyXG4gICAgICAgICAgICBjb25zdCB2MkRyYWZ0OiBEcmFmdERhdGFWMiA9IHtcclxuICAgICAgICAgICAgICBkcmFmdElkOiB0aGlzLmdlbmVyYXRlRHJhZnRJZCgpLFxyXG4gICAgICAgICAgICAgIGNyZWF0aXZlRmlsZW5hbWU6IHBhcnNlZC5jcmVhdGl2ZUZpbGVuYW1lIHx8IGZpbGVuYW1lLFxyXG4gICAgICAgICAgICAgIGxhc3RTYXZlZDogcGFyc2VkLnNhdmVkQXQgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICAgIGF1dG9TYXZlZDogcGFyc2VkLmF1dG9TYXZlZCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICBmb3JtRGF0YTogcGFyc2VkLFxyXG4gICAgICAgICAgICAgIGltYWdlVXJsOiB1bmRlZmluZWQgLy8gTGVnYWN5IGZvcm1hdCBkaWRuJ3Qgc3RvcmUgaW1hZ2UgVVJMc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBTYXZlIGFzIFYyXHJcbiAgICAgICAgICAgIGNvbnN0IHYyS2V5ID0gYCR7dGhpcy5WMl9QUkVGSVh9JHt2MkRyYWZ0LmRyYWZ0SWR9YFxyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh2MktleSwgSlNPTi5zdHJpbmdpZnkodjJEcmFmdCkpXHJcbiAgICAgICAgICAgIG1pZ3JhdGVkLnB1c2goa2V5KVxyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbWlncmF0ZSBkcmFmdDonLCBrZXksIGUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFJlbW92ZSBtaWdyYXRlZCBsZWdhY3kgZHJhZnRzXHJcbiAgICBtaWdyYXRlZC5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcclxuICAgIH0pXHJcbiAgICBcclxuICAgIGlmIChtaWdyYXRlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBNaWdyYXRlZCAke21pZ3JhdGVkLmxlbmd0aH0gZHJhZnRzIHRvIFYyIGZvcm1hdGApXHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHByaXZhdGUgc3RhdGljIGdldExlZ2FjeURyYWZ0KGZpbGVuYW1lOiBzdHJpbmcpOiBEcmFmdERhdGFWMiB8IG51bGwge1xyXG4gICAgY29uc3Qga2V5ID0gYCR7dGhpcy5EUkFGVF9QUkVGSVh9JHtmaWxlbmFtZX1gXHJcbiAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGRyYWZ0SWQ6IGZpbGVuYW1lLFxyXG4gICAgICAgICAgY3JlYXRpdmVGaWxlbmFtZTogcGFyc2VkLmNyZWF0aXZlRmlsZW5hbWUgfHwgZmlsZW5hbWUsXHJcbiAgICAgICAgICBsYXN0U2F2ZWQ6IHBhcnNlZC5zYXZlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIGF1dG9TYXZlZDogcGFyc2VkLmF1dG9TYXZlZCB8fCBmYWxzZSxcclxuICAgICAgICAgIGZvcm1EYXRhOiBwYXJzZWQsXHJcbiAgICAgICAgICBpbWFnZVVybDogdW5kZWZpbmVkXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIGxlZ2FjeSBkcmFmdDonLCBrZXksIGUpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG4gIFxyXG4gIHByaXZhdGUgc3RhdGljIGdldExlZ2FjeURyYWZ0QnlLZXkoa2V5OiBzdHJpbmcpOiBEcmFmdERhdGFWMiB8IG51bGwge1xyXG4gICAgY29uc3QgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSlcclxuICAgIGlmIChkYXRhKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKVxyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0ga2V5LnJlcGxhY2UodGhpcy5EUkFGVF9QUkVGSVgsICcnKVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBkcmFmdElkOiBmaWxlbmFtZSxcclxuICAgICAgICAgIGNyZWF0aXZlRmlsZW5hbWU6IHBhcnNlZC5jcmVhdGl2ZUZpbGVuYW1lIHx8IGZpbGVuYW1lLFxyXG4gICAgICAgICAgbGFzdFNhdmVkOiBwYXJzZWQuc2F2ZWRBdCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICBhdXRvU2F2ZWQ6IHBhcnNlZC5hdXRvU2F2ZWQgfHwgZmFsc2UsXHJcbiAgICAgICAgICBmb3JtRGF0YTogcGFyc2VkLFxyXG4gICAgICAgICAgaW1hZ2VVcmw6IHVuZGVmaW5lZFxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBsZWdhY3kgZHJhZnQ6Jywga2V5LCBlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuICBcclxuICBwcml2YXRlIHN0YXRpYyBnZW5lcmF0ZURyYWZ0SWQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBgJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIkRyYWZ0U3RvcmFnZVYyIiwic2F2ZURyYWZ0IiwiZGF0YSIsImRyYWZ0SWQiLCJnZW5lcmF0ZURyYWZ0SWQiLCJkcmFmdERhdGEiLCJjcmVhdGl2ZUZpbGVuYW1lIiwibGFzdFNhdmVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiYXV0b1NhdmVkIiwiZm9ybURhdGEiLCJpbWFnZVVybCIsImtleSIsIlYyX1BSRUZJWCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0RHJhZnQiLCJnZXRJdGVtIiwicGFyc2UiLCJsZWdhY3lEYXRhIiwiZ2V0TGVnYWN5RHJhZnQiLCJnZXRBbGxEcmFmdHMiLCJkcmFmdHMiLCJpIiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsInB1c2giLCJlIiwiY29uc29sZSIsImVycm9yIiwiRFJBRlRfUFJFRklYIiwibGVnYWN5RHJhZnQiLCJnZXRMZWdhY3lEcmFmdEJ5S2V5Iiwic29tZSIsImQiLCJkZWxldGVEcmFmdCIsInYyS2V5IiwicmVtb3ZlSXRlbSIsInBhcnNlZCIsIm1pZ3JhdGVGcm9tVjEiLCJtaWdyYXRlZCIsImZpbGVuYW1lIiwicmVwbGFjZSIsInYyRHJhZnQiLCJzYXZlZEF0IiwidW5kZWZpbmVkIiwiZm9yRWFjaCIsImxvZyIsIk1hdGgiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/draftStorage.v2.ts\n"));

/***/ })

}]);